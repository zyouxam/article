# 题目

波雷卡普和瓦西里喜欢简单的逻辑游戏。今天他们玩了一个游戏，这个游戏在一个很大的棋盘上进行，他们每个人有一个棋子。他们轮流移动自己的棋子，波雷卡普先开始。每一步移动中，波雷卡普可以将他的棋子从(x,y) 移动到 (x-1,y) 或者 (x,y-1)。而瓦西里可以将他的棋子从(x,y) 移动到 (x-1,y),(x-1,y-1) 或者 (x,y-1)。当然他们可以选择不移动。

还有一些其它的限制，他们不能把棋子移动到x或y为负的座标，或者移动到已经被对手占据的座标。最先到达（0，0）的人获胜。

现在给定他们棋子的座标，判断一下谁会获胜。

# 输入格式

单组测试数据。 第一行包含四个整数$x_p,y_p,x_v,y_v (0≤x_p,y_p,x_v,y_v≤10^5)$ ，表示波雷卡普和瓦西里棋子的座标。 输入保证他们的棋子在不同位置，而且没有棋子在（0，0）。

# 输出格式

果波雷卡普获胜，输出Polycarp，否则输出Vasiliy。

# 输入样例

```
2 1 2 2
```

# 输出样例

```
Polycarp
```

# 题解

站在波雷卡普角度思考, 如果他的横纵坐标都比另一个人小或者相投, 一定能赢, 因为无论如何, 都可以挡住另一个人, 而又因为他是先手, 所以横纵坐标可以相等.


还有一种情况, 就是另一个人直走对角线, 还是比他要慢, 那么怎么计算对角线? 考虑可能的对角线加上部分直线, 时间其实和横纵坐标里最长的相同, 画一画很容易明白.

# 代码

```c++
#include <iostream>
int main() {
    int x, y, p, q;
    std::cin >> x >> y >> p >> q;
    std::cout << (((x <= p && y <= q) || std::max(p, q) >= x + y)?"Polycarp":"Vasiliy") << std::endl;
    return 0;
}
```