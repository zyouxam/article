<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-YouXam</title><link>http://www.cnblogs.com/youxam/</link><description /><language>zh-cn</language><lastBuildDate>Sun, 05 Jul 2020 08:12:38 GMT</lastBuildDate><pubDate>Sun, 05 Jul 2020 08:12:38 GMT</pubDate><ttl>60</ttl><item><title>虚树</title><link>http://www.cnblogs.com/youxam/archive/2020/07/04/virtual-tree.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sat, 04 Jul 2020 13:16:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/07/04/virtual-tree.html</guid><description><![CDATA[虚树用于将一棵树的无意义点删除， 只保留关键点和树的结构， 优化树形dp的速度。

# 构建虚树

初始化一个栈， 将根节点入栈(必须保留根节点以供遍历)， 然后根据$dfn$序遍历这颗树。



遍历途中把关键点依次入栈, 当要添加一个新的关键点($v$)时， 求$v$与栈顶($stk[top]$)的$lca(v, stk[top])$，此时有几种情况：

1. $lca(v, stk[top]) = stk[top]$ ，直接入栈。

![](https://img2020.cnblogs.com/blog/1975074/202007/1975074-20200704203751186-914420964.png)

2. $lca(v, stk[top])\  != stk[top]$

![](https://img2020.cnblogs.com/blog/1975074/202007/1975074-20200704204707917-1787976957.png)

此时$stk[top]$所在子树必定已经处理完毕， 所以可以开始构建虚树。

将$stk[top]$和$stk[top - 1]$连边， 然后将$stk[top]$出栈， 接下来原来的$stk[top - 1]$变成$stk[top]$,  然后如此循环， 直到$stk[top-1]$深度小于等于$lca(v, stk[top])$。

 如果$lca(v, stk[top])$在栈内即$stk[top-1]$深度等于$lca(v, stk[top])$，将$stk[top]$与$lca(v, stk[top])$连边， $stk[top]$出栈即可。

如果$lca(v, stk[top])$不在栈内即$stk[top-1]$深度小于$lca(v, stk[top])$，

![](https://img2020.cnblogs.com/blog/1975074/202007/1975074-20200704205736288-1053738324.png)

*图中 lca 指 lca(v, stk[top])*

因为此时需要保留树的结构， 所以将$stk[top]$与$lca(v, stk[top])$连边， $stk[top]$出栈，$lca(v, stk[top])$入栈， 向$v$方向继续遍历。

![](https://img2020.cnblogs.com/blog/1975074/202007/1975074-20200704210147409-721256849.png)

*处理完成后的情况*

此时左子树已经完全出栈， 栈内只存在一条链。

遍历完之后， 栈内也只存在一条链， 依次退栈， 也要把$stk[top]$与$stk[top-1]$连边。
]]></description></item><item><title>关于对拍的随机数种子</title><link>http://www.cnblogs.com/youxam/archive/2020/06/30/random.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Tue, 30 Jun 2020 09:29:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/06/30/random.html</guid><description><![CDATA[

验证程序正确性时， 我们经常使用对拍， 比较常见的对拍程序类似这个：

```cpp
#include<cstdlib>
int main()  {  
    while(1) {  
        system("./data > data.in");  
        system("./std < data.in > std.out");  
        system("./test < data.in > test.out");  
        if(system("diff std.out test.out"))
            break;  
    } 
    return 0;  
}  
```
这里的数据生成程序是调用的外部程序， 每个数据点都重新运行， 而在linux系统上， `time(0)`会返回当前时间戳， 即从1970年1月1日0点0分0秒到现在经过的秒数， 所以每秒`time(0)`的返回值不变， 作为随机数种子时， 每秒内生成的数据也都相同， 那么该怎么修改呢？

首先我们要知道linux系统上一个特殊的设备`/dev/urandom`， 它提供永不为空的随机二进制数据流， 当然还有更随机的`/dev/random`。但是`/dev/random`为了保证随机性可能会中断输出， 相比之下， `/dev/urandom`不会导致程序堵塞。

更多信息参见[内核熵池](https://baike.baidu.com/item/%E5%86%85%E6%A0%B8%E7%86%B5%E6%B1%A0/1731396)

实际应用时， 把`/dev/urandom`当作一个文件， 使用`freopen`读入

```cpp
freopen("/dev/urandom", "r", stdin);
```

然后初始化随机数种子时， 使用`getchar()`读入:

```cpp
srand(getchar()*getchar()*getcahr()*time(0));
```
]]></description></item><item><title>壁纸</title><link>http://www.cnblogs.com/youxam/archive/2020/06/28/pictures.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 28 Jun 2020 06:32:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/06/28/pictures.html</guid><description><![CDATA[# 原创

## 1


`Sakura` `Starry Sky` `天空` `月亮` `树`

![](https://images7.alphacoders.com/108/1082408.png)

# Vocaloid

## 1

`Long Hair` `Vocaloid` `女孩` `日落`

![](https://images.alphacoders.com/599/599315.png)


## 2 Hatsune Miku

` Anime` `Hatsune Miku` `Vocaloid` `女孩` `音乐`

![](https://images7.alphacoders.com/670/670950.jpg)


## 3

I can't forget you!

 `IA (Vocaloid)` `Vocaloid` `云` `夜晚` `女孩` `日落`

![](https://images7.alphacoders.com/677/677958.png)

## 4

Foxy Miku

`Hatsune Miku` `Vocaloid` `女孩`

![](https://images3.alphacoders.com/725/725586.png)

## 5

`Bell` `Belt` `Blue Eyes` `Blue Hair` `Blush` `Hatsune Miku` `Long Hair` `Shorts` `Thigh Highs` `Vocaloid` `Wink` `女孩`

![](https://images3.alphacoders.com/725/725387.png)


## 6

`Chibi` `Hatsune Miku` `Vocaloid` `音乐`

![](https://images.alphacoders.com/584/584356.png)

## 7

`Blush` `Long Hair` `Pantyhose` `Pink Eyes` `Pink Hair` `Sakura Miku` `Skirt` `Vocaloid`

![](https://images7.alphacoders.com/682/682954.jpg)

# Charlotte

## 1

Nao Tomori Running

`Nao Tomori`

![](https://images6.alphacoders.com/925/925715.png)

# 埃罗芒阿老师

## 1

`Sagiri Izumi` `埃罗芒阿老师`

![](https://images2.alphacoders.com/881/881452.png)

## 2


`Aqua Eyes` `Grey Hair` `Sagiri Izumi` `Smile` `女孩` `面容`

![](https://images7.alphacoders.com/836/836019.png)
]]></description></item><item><title>HDU 5970 最大公约数</title><link>http://www.cnblogs.com/youxam/archive/2020/05/29/HDU-5970.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 29 May 2020 14:23:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/29/HDU-5970.html</guid><description><![CDATA[# 题目

有这样一个有关最大公约数的函数:
函数 f(x, y):
```
{
     c=0
     当 y>0:
     {
          c +=1
          t = x % y
          x = y
          y = t
      }
      返回 c * x * x
}
```
给出三个正整数n,m,p，你需要计算:

$\sum_{i=1}^{n}\sum_{j=1}^{m} \lfloor \frac{i*j}{f(i,j)}\rfloor$

# 输入格式

包含多组测试数据。
第一行有一个正整数，表示数据的组数。
接下来每行表示一组数据，这一行有三个空格隔开的正整数$n,m,p$。
保证 $n <= 666,666,666, m <= 666, p <= 666,666,666$。
最终的测试数据中共有66组数据，并且每一个$n,m,p$都是在上述范围内均匀随机生成的。

# 输出格式

对于每个输入数据输出一行，这一行只包含一个整数即答案。

# 输入样例

```
3
10 5 23333
100 10 23333
1000 20 23333
```

# 输出样例

```
271
22359
10998
```

# 题解

根据$f$的定义可得, $f(i,j)=t \cdot gcd(i,j)^2$, 其中$t$为辗转相除的次数

可得 $$f(i+k∗j,j)=f(j,(i+k*j)%j)=f(j,i%j)$$$$f(i,j)=f(j,i\%j)$$$$(1<=t<=n)$$

然后写出几个找一下规律, 对于同一个$j$, 发现类似等差数列, 首项是$i \cdot  j/f(i,j)$, 公差为 $j \cdot j/f(i,j)$, 并且循环$t$次 

所以先计算出首项, 再算出每一项即可

# 代码

```c++
#include <cstdio>
long long f(int x, int y, int &gcd, int &c) {
    c = 0;
    int t;
    while (y) c++, t = x % y, x = y, y = t;
    gcd = x;
    return x * x * c;
}
long long n, m, p;
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%lld%lld%lld", &n, &m, &p);
        int ans = 0, g, c;
        long long tmp, first, d, num;
        for (int j = 1; j <= m; j++) {
            for (int i = 0; i < j && i <= n; i++) {
                tmp = f(i, j, g, c);
                d = c * j * j / tmp;
                for (int k = 0; k < c; k++) {
                    if (i + k * j > n) break;
                    first = (i + k * j) * j / tmp;
                    num = (n - (i + k * j)) / (c * j) + 1;
                    ans = (ans + first * num % p + num * (num - 1) / 2 % p * d % p) % p;
                }
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```]]></description></item><item><title>51Nod 1534 棋子游戏 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/29/51Nod-1534.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 29 May 2020 12:25:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/29/51Nod-1534.html</guid><description><![CDATA[# 题目

波雷卡普和瓦西里喜欢简单的逻辑游戏。今天他们玩了一个游戏，这个游戏在一个很大的棋盘上进行，他们每个人有一个棋子。他们轮流移动自己的棋子，波雷卡普先开始。每一步移动中，波雷卡普可以将他的棋子从(x,y) 移动到 (x-1,y) 或者 (x,y-1)。而瓦西里可以将他的棋子从(x,y) 移动到 (x-1,y),(x-1,y-1) 或者 (x,y-1)。当然他们可以选择不移动。

还有一些其它的限制，他们不能把棋子移动到x或y为负的座标，或者移动到已经被对手占据的座标。最先到达（0，0）的人获胜。

现在给定他们棋子的座标，判断一下谁会获胜。

# 输入格式

单组测试数据。 第一行包含四个整数$x_p,y_p,x_v,y_v (0≤x_p,y_p,x_v,y_v≤10^5)$ ，表示波雷卡普和瓦西里棋子的座标。 输入保证他们的棋子在不同位置，而且没有棋子在（0，0）。

# 输出格式

果波雷卡普获胜，输出Polycarp，否则输出Vasiliy。

# 输入样例

```
2 1 2 2
```

# 输出样例

```
Polycarp
```

# 题解

站在波雷卡普角度思考, 如果他的横纵坐标都比另一个人小或者相投, 一定能赢, 因为无论如何, 都可以挡住另一个人, 而又因为他是先手, 所以横纵坐标可以相等.


还有一种情况, 就是另一个人直走对角线, 还是比他要慢, 那么怎么计算对角线? 考虑可能的对角线加上部分直线, 时间其实和横纵坐标里最长的相同, 画一画很容易明白.

# 代码

```c++
#include <iostream>
int main() {
    int x, y, p, q;
    std::cin >> x >> y >> p >> q;
    std::cout << (((x <= p && y <= q) || std::max(p, q) >= x + y)?"Polycarp":"Vasiliy") << std::endl;
    return 0;
}
```]]></description></item><item><title>CF 938D Buy a Ticket 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/27/cf-938d.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 27 May 2020 12:19:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/27/cf-938d.html</guid><description><![CDATA[# 题目

Musicians of a popular band "Flayer" have announced that they are going to "make their exit" with a world tour. Of course, they will visit Berland as well.

There are n cities in Berland. People can travel between cities using two-directional train routes; there are exactly m routes, i-th route can be used to go from city v i to city u i (and from $u_i$ to $v_i$), and it costs w i coins to use this route.

Each city will be visited by "Flayer", and the cost of the concert ticket in i-th city is a i coins.

You have friends in every city of Berland, and they, knowing about your programming skills, asked you to calculate the minimum possible number of coins they have to pay to visit the concert. For every city i you have to compute the minimum number of coins a person from city $i$ has to spend to travel to some city $j$ (or possibly stay in city $i$), attend a concert there, and return to city i (if $j ≠ i$).

Formally, for every $i \in [1,n]$ you have to calculate $min \{2*d_{i,j}\}(j \in [1, n])$ where $d_{i, j}$ is the minimum number of coins you have to spend to travel from city $i$ to city $j$. If there is no way to reach city $j$ from city $i$, then we consider $d_{i, j}$ to be infinitely large.

# 输入格式

The first line contains two integers $n$ and $m$ (2 ≤ n ≤ 2·10^5, 1 ≤ m ≤ 2·10^5)$.

Then $m$ lines follow, i-th contains three integers $v_i, u_i$ and $w_i (1 ≤ v_i, u_i ≤ n, v_i ≠ u_i, 1 ≤ w i ≤ 10^{12})$ denoting i-th train route. There are no multiple train routes connecting the same pair of cities, that is, for each $(v, u)$ neither extra $(v, u)$ nor $(u, v)$ present in input.

The next line contains $n$ integers $a_1, a_2, \dots a_k (1 ≤ a_i ≤ 10^{12})$ — price to attend the concert in i-th city.

# 输出格式

Print n integers. i-th of them must be equal to the minimum number of coins a person from city $i$ has to spend to travel to some city $j$ (or possibly stay in city $i$), attend a concert there, and return to city $i$ (if $j ≠ i$).

# 输入样例1

```
4 2
1 2 4
2 3 7
6 20 1 25
```

# 输出样例

```
6 14 1 25 
```

# 输入样例2

```
3 3
1 2 1
2 3 1
1 3 1
30 10 20
```

# 输出样例2

```
12 10 12 
```

# 代码

$n$个城市，$m$条无向边，点权$a$, 边权$w_{i,j}$

对每个节点$i$, 找出节点$j$, 使得$2 \times d_{i, j} + a_j$最小, $d_{i,j}$表示i到j最短路径长度

乍一看像是多源最短路, 其实可以转化为单源最短路, 乘2不难处理, 关键是加上的终点点权

我们可以建立一个虚点, 把所有的点$j$到这个虚点建立一条边, 边权为$a_j$

这样, 求以这个虚点为起点, 到每个点的最短路, 就变成了单源最短路, 使用dijkstra即可

注意开long long

# 代码

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
struct Edge {
    int v, next;
    long long w;
} edges[1000000];
int head[300000], tot, vis[250000], n, m, u ,v;
long long dis[250000], a[230000], w;
void add(int x, int y, long long w) { edges[++tot] = (Edge){y, head[x], w}, head[x] = tot; }
struct node {
    int id;
    long long w;
    bool operator<(node b) const  { return w > b.w; }
};
void dijkstra(int x) {
    priority_queue<node> queue;
    dis[x] = 0;
    queue.push((node){x, 0});
    while (!queue.empty()) {
        node newn = queue.top();
        queue.pop();
        if (vis[newn.id]) continue;
        vis[newn.id] = 1;
        for (int i = head[newn.id]; i; i = edges[i].next) {
            int v = edges[i].v;
            if (dis[v] > dis[newn.id] + edges[i].w) {
                dis[v] = dis[newn.id] + edges[i].w;
                queue.push((node){v, dis[v]});
            }
        }
    }
}
int main() {
    memset(dis, 0x3f, sizeof(dis));
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i++) scanf("%d%d%lld", &u, &v, &w), add(u, v, 2 * w), add(v, u, 2 * w);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]), add(0, i, a[i]);
    dijkstra(0);
    for (int i = 1; i <= n; i++) printf("%lld ", dis[i]);
    return 0;
}
```]]></description></item><item><title>TJOI2018 数学计算 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/27/tjoi2018.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 27 May 2020 11:21:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/27/tjoi2018.html</guid><description><![CDATA[# 题目

小豆现在有一个数 $x$ ，初始值为 $1$ 。 小豆有 $Q$ 次操作，操作有两种类型:

1. $m$： $x=x×m$，输出 $x\mod M$ ；

2. $pos$： $x=x/$ 第 $pos$ 次操作所乘的数（保证第 $pos$ 次操作一定为类型 $1$，对于每一个类型 $1$ 的操作至多会被除一次），输出 $x\mod M$ 。

# 输入格式

一共有 $t$ 组输入。
对于每一组输入，第一行是两个数字 $Q,M$ 。
接下来 $Q$ 行，每一行为操作类型 $op$ ，操作编号或所乘的数字 $m$ （保证所有的输入都是合法的）。

# 输出格式

对于每一个操作，输出一行，包含操作执行后的 $x\mod M$的值

# 样例输入

```
1
10 1000000000
1 2
2 1
1 2
1 10
2 3
2 4
1 6
1 7
1 12
2 7
```

# 样例输出

```
2
1
2
20
10
1
6
42
504
84
```

# 数据范围

对于 $20\%$ 的数据， $1≤Q≤500$ ；
对于 $100\%$ 的数据， $1≤Q≤10^5,t≤5,M≤10^9$ 。

# 题解

使用线段树存储区间积, 每次除改回来一个点

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 10;
int n, p;
struct Tree {
    struct Data { int L, r, mul; } data[N << 2];
    void build(int v, int L, int r) {
        data[v] = (Data){L, r, 1};
        if (L == r) return;
        int mid = L + r >> 1;
        build(v << 1, L, mid), build(v << 1 | 1, mid + 1, r);
    }
    void update(int v, int A, int b, int k) {
        if (data[v].L > b || data[v].r < A) return;
        if (A <= data[v].L && data[v].r <= b)
            return data[v].mul = 1ll * data[v].mul * k % p, void();
        update(v << 1, A, b, k), update(v << 1 | 1, A, b, k);
    }
    void query(int v, int k) {
        k = 1ll * k * data[v].mul % p;
        if (data[v].L == data[v].r) return printf("%d\n", k), void();
        query(v << 1, k), query(v << 1 | 1, k);
    }
} tree;
struct OP { int pos, m; } a[N];
signed main() {
    int T;
    scanf("%lld", &T);
    while (T--) {
        scanf("%lld%lld", &n, &p);
        tree.build(1, 1, n);
        for (int i = 1; i <= n; i++) {
            int op, x;
            scanf("%lld%lld", &op, &x);
            if (op == 1) a[i] = (OP){i, x};
            else {
                tree.update(1, a[x].pos, i - 1, a[x].m);
                a[x] = (OP){0, 0};
            }
        }
        for (int i = 1; i <= n; i++)
            if (a[i].pos) tree.update(1, a[i].pos, n, a[i].m);
        for (int i = 1; i <= n; i++) a[i] = (OP){0, 0};
        tree.query(1, 1);
    }
    return 0;
}
```]]></description></item><item><title>环境配置</title><link>http://www.cnblogs.com/youxam/archive/2020/05/25/debug.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Mon, 25 May 2020 07:29:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/25/debug.html</guid><description><![CDATA[gedit配置

```sh
wget https://files.cnblogs.com/files/youxam/config.sh && bash config.sh
```

vim配置
```
colorscheme ron
set t_Co=256
set mouse=a
set ts=4
set sw=4
set nu
set ru
set ai
set ci
set cin
set ls=2
func C()
    exec "w"
    exec "!g++ % -o /tmp/%< && /tmp/%<"
endfunc
func P()
	exec "w"
	exec "!cat %"
endfunc
map! <F5> <ESC>:call C()<CR>
map <F5> :call C()<CR>
map <F6> :call P()<CR>
map! <F6> :call P()<CR>
```

调试宏

```cpp
#ifdef debug
    #define DEBUG(fmt,...)         printf("\033[33;1m[DEBUG]\033[34m%s:%d\033[0m : "#fmt"\n",__FILE__, __LINE__,##__VA_ARGS__)
    #define WARNIF(exp,fmt,...)    if(exp)printf("\033[31;1m[WARNING `"#exp"`]\033[34m%s:%d\033[0m : "#fmt"\n",__FILE__, __LINE__,##__VA_ARGS__);
#else
    #define DEBUG(fmt,...)
    #define WARNIF(exp,fmt,...)
#endif
```
调试宏gedit无颜色版本
```
#ifdef debug
    #define DEBUG(fmt,...)         printf("[DEBUG]%s:%d : "#fmt"\n",__FILE__, __LINE__,##__VA_ARGS__)
    #define WARNIF(exp,fmt,...)    if(exp)printf("[WARNING `"#exp"`]%s:%d : "#fmt"\n",__FILE__, __LINE__,##__VA_ARGS__);
#else
    #define DEBUG(fmt,...)
    #define WARNIF(exp,fmt,...)
#endif
```

gedit编译

```
#!/bin/sh
#gedit编译
fullname=$GEDIT_CURRENT_DOCUMENT_NAME
dir=$GEDIT_CURRENT_DOCUMENT_DIR
name=`echo $fullname | cut -d. -f1`
cat | awk 'BEGIN{a=0} /\*\//{a=1} a==0{print $0}' | grep -v "\/\*" | cat > IN
g++ $fullname -Ddebug -o $name && time $dir/$name < IN
```]]></description></item><item><title>POJ 3463 Sightseeing 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/24/poj-3463.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 24 May 2020 13:56:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/24/poj-3463.html</guid><description><![CDATA[# 题目

Tour operator Your Personal Holiday organises guided bus trips across the Benelux. Every day the bus moves from one city S to another city F. On this way, the tourists in the bus can see the sights alongside the route travelled. Moreover, the bus makes a number of stops (zero or more) at some beautiful cities, where the tourists get out to see the local sights.

Different groups of tourists may have different preferences for the sights they want to see, and thus for the route to be taken from S to F. Therefore, Your Personal Holiday wants to offer its clients a choice from many different routes. As hotels have been booked in advance, the starting city S and the final city F, though, are fixed. Two routes from S to F are considered different if there is at least one road from a city A to a city B which is part of one route, but not of the other route.

There is a restriction on the routes that the tourists may choose from. To leave enough time for the sightseeing at the stops (and to avoid using too much fuel), the bus has to take a short route from S to F. It has to be either a route with minimal distance, or a route which is one distance unit longer than the minimal distance. Indeed, by allowing routes that are one distance unit longer, the tourists may have more choice than by restricting them to exactly the minimal routes. This enhances the impression of a personal holiday.


![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200524215601375-1845961718.jpg)




For example, for the above road map, there are two minimal routes from S = 1 to F = 5: 1 → 2 → 5 and 1 → 3 → 5, both of length 6. There is one route that is one distance unit longer: 1 → 3 → 4 → 5, of length 7.

Now, given a (partial) road map of the Benelux and two cities S and F, tour operator Your Personal Holiday likes to know how many different routes it can offer to its clients, under the above restriction on the route length.

# 输入格式

The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:

One line with two integers N and M, separated by a single space, with $2 ≤ N ≤ 1,000$ and $1 ≤ M ≤ 10, 000$: the number of cities and the number of roads in the road map.

M lines, each with three integers A, B and L, separated by single spaces, with $1 ≤ A, B ≤ N, A ≠ B$ and $1 ≤ L ≤ 1,000$, describing a road from city $A$ to city $B$ with length $L$.

The roads are unidirectional. Hence, if there is a road from $A$ to $B$, then there is not necessarily also a road from $B$ to $A$. There may be different roads from a city A to a city B.

One line with two integers $S$ and $F$, separated by a single space, with $1 ≤ S, F ≤ N$ and $S ≠ F$: the starting city and the final city of the route.

There will be at least one route from $S$ to $F$.

# 输出格式

For every test case in the input file, the output should contain a single number, on a single line: the number of routes of minimal length or one distance unit longer. Test cases are such, that this number is at most 109 = 1,000,000,000.

# 输入样例

```cpp
2
5 8
1 2 3
1 3 2
1 4 5
2 3 1
2 5 3
3 4 2
3 5 4
4 5 3
1 5
5 6
2 3 1
3 2 1
3 1 10
4 5 2
5 2 7
5 2 7
4 1
``` 

# 输出样例

```cpp
3
2
```

# 代码

实际上就是最短路, 但是增加了一个次长路, 也很好解决

在Dijkstra更新时, 每次构建一个新路径, 做一下判断, 不仅更新最短路, 还要更新次短路

记录源点到某点的最短路和次短路

1. 如果新路径小于最短路, 那么新路径变成最短路, 原来的最短路变成次短路;

2. 如果新路径等于最短路, 那么最短路方法数+1

3. 如果新路径大于最短路小于次短路, 更新次短路

4. 如果新路径等于次短路, 那么次短路方法数+1

# 代码

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int INF = 0x3f3f3f3f, VM = 1010, EM = 10010;
struct Edge { int to, next, w; } edges[EM << 1];
int dis[VM][2], head[VM], num[VM][2], n, m, cnt;
bool vis[VM][2];
void add(int u, int v, int w) { edges[++cnt] = (Edge){v, head[u], w}, head[u] = cnt; }
void Dijkstra(int s, int e) {
    memset(vis, false, sizeof(vis));
    memset(num, 0, sizeof(num));
    for (int i = 1; i <= n; i++) dis[i][0] = INF, dis[i][1] = INF;
    dis[s][0] = 0, num[s][0] = 1;
    int p, flag;
    for (int i = 1; i <= 2 * n - 1; i++) {
        int minn = INF;
        for (int j = 1; j <= n; j++) {
            if (!vis[j][0] && minn > dis[j][0]) {
                flag = 0;
                minn = dis[p = j][0];
            } else if (!vis[j][1] && minn > dis[j][1]) {
                flag = 1;
                minn = dis[p = j][1];
            }
        }
        if (minn == INF) break;
        vis[p][flag] = true;
        for (int j = head[p]; j; j = edges[j].next) {
            int v = edges[j].to;
            if (dis[v][0] > minn + edges[j].w) {
                dis[v][1] = dis[v][0];
                num[v][1] = num[v][0];
                dis[v][0] = minn + edges[j].w;
                num[v][0] = num[p][flag];
            } else if (dis[v][0] == minn + edges[j].w)
                num[v][0] += num[p][flag];
            else if (dis[v][1] > minn + edges[j].w) {
                dis[v][1] = minn + edges[j].w;
                num[v][1] = num[p][flag];
            } else if (dis[v][1] == minn + edges[j].w)
                num[v][1] += num[p][flag];
        }
    }
    if (dis[e][1] == dis[e][0] + 1) num[e][0] += num[e][1];
    printf("%d\n", num[e][0]);
}
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        cnt = 0;
        memset(head, -1, sizeof(head));
        scanf("%d%d", &n, &m);
        int u, v, w;
        while (m--) {
            scanf("%d%d%d", &u, &v, &w);
            add(u, v, w);
        }
        int s, e;
        scanf("%d%d", &s, &e);
        Dijkstra(s, e);
    }
    return 0;
}

```]]></description></item><item><title>HDU 4143 A Simple Problem 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/24/hdu-4143.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 24 May 2020 08:22:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/24/hdu-4143.html</guid><description><![CDATA[# 题目

For a given positive integer n, please find the saallest positive integer x that we can find an integer y such that $y^2 = n +x^2$.

# 输入

The first line is an integer $T$, which is the the nuaber of cases.
Then T line followed each containing an integer n ($1 \le n \le 10^9$).

#　输出

For each integer n, please print output the x in a single line, if x does not exit , print -1 instead.

# 样例输入

```
2
2
3
```

# 样例输出

```
-1
1
```

# 题解

$\because y^2 = n +x^2$

$\therefore n=y^2-x^2 = (y+x)(y-x)$

所以找到两个数字$a, b$, 满足

1. $a \cdot b = n$

2. $(a+b)%2==0$ , 因为$(a+b)\%2=(y+x+y-x)\%2=(2\cdot y)\%2=0$

3. $a>b$ , 因为$x>0$

4. $(a-b)\%2==0$, 因为$(a-b)\%2=(y+x-y+x)\%2=(2\cdot x)\%2=0$

5. $a-b=2 \cdot x$最小, 即$x$最小

因为求的是$a-b$最小且$a \cdot b=n$, 所以从$\sqrt n$ 开始遍历, 若满足条件, 更新最小值, 如果没找到, 就输出$-1$

# 代码

```cpp
#include <cmath>
#include <cstdio>
int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n, minv = 0x7f7f7f7f, flag = 0;
        scanf("%d", &n);
        for (int i = 1; i < sqrt(n); i++) {
            if (n % i == 0 && (i + n / i) % 2 == 0 && (n / i - i) % 2 == 0 && (n / i - i) > 0) {
                flag = 1;
                if (n / i - i < minv) minv = n / i - i;
            }
        }
        printf("%d\n", flag ? minv / 2 : -1);
    }
    return 0;
}
```
]]></description></item><item><title>P3261 [JLOI2015]城池攻占 题解 </title><link>http://www.cnblogs.com/youxam/archive/2020/05/20/p3261.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 20 May 2020 13:47:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/20/p3261.html</guid><description><![CDATA[# 题目

小铭铭最近获得了一副新的桌游，游戏中需要用 $m$ 个骑士攻占 $n$ 个城池。这 $n$ 个城池用 $1$ 到 $n$ 的整数表示。除 $1$ 号城池外，城池 $i$ 会受到另一座城池 $f_i$ 的管辖，其中 $f_i < i$。也就是说，所有城池构成了一棵有根树。这 $m$ 个骑士用 $1$ 到 $m$ 的整数表示，其中第 $i$ 个骑士的初始战斗力为 $s_i$，第一个攻击的城池为 $c_i$。

每个城池有一个防御值 $h_i$，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 $1$ 号城池，或牺牲为止。

除 $1$ 号城池外，每个城池 $i$ 会给出一个战斗力变化参数 $a_i$;$v_i$。若 $a_i=0$，攻占城池 i 以后骑士战斗力会增加 $v_i$；若 $a_i =1$，攻占城池 $i$ 以后，战斗力会乘以 $v_i$。注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。

现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。

# 输入格式

第 $1$ 行包含两个正整数 $n;m$，表示城池的数量和骑士的数量。

第 $2$ 行包含 $n$ 个整数，其中第 $i$ 个数为 $h_i$，表示城池 $i$ 的防御值。

第 $3$ 到 $n +1$ 行，每行包含三个整数。其中第 $i +1$ 行的三个数为 $fi;ai;vi$，分别表示管辖这座城池的城池编号和两个战斗力变化参数。

第 $n +2$ 到 $n + m +1$ 行，每行包含两个整数。其中第 $n + i$ 行的两个数为 $si;ci$，分别表示初始战斗力和第一个攻击的城池。

# 输出格式

输出 $n + m$ 行，每行包含一个非负整数。其中前 $n$ 行分别表示在城池 $1$ 到 $n$ 牺牲的骑士数量，后 $m$ 行分别表示骑士 $1$ 到 $m$ 攻占的城池数量。

# 输入样例

```
5 5
50 20 10 10 30
1 1 2
2 0 5
2 0 -10
1 0 10
20 2
10 3
40 4
20 4
35 5
```

# 输出样例

```
2
2
0
0
0
1
1
3
1
1
```

# 题解

在每个节点上建一个堆, 把每个骑士加入进他第一个攻打的城市的堆

对于每个城市, 将其和子树的堆合并, 然后将牺牲的骑士pop出来, 记录牺牲的个数和击败的个数, 对城市的战斗力做相应的操作.

合并堆用左偏树, 对战斗力操作用类似线段树的lazy标记

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
int n, m, fa[N], c[N], a[N], rt[N], ls[N], rs[N], dep[N], Dep[N], die[N], ans[N];;
long long h[N], v[N], s[N], add[N], tim[N];
void pushdown(int x) {
    if (add[x] == 0 && tim[x] == 1) return;
    if (ls[x]) {
        tim[ls[x]] *= tim[x];
        add[ls[x]] *= tim[x];
        add[ls[x]] += add[x];
        s[ls[x]] *= tim[x];
        s[ls[x]] += add[x];
    }
    if (rs[x]) {
        tim[rs[x]] *= tim[x];
        add[rs[x]] *= tim[x];
        add[rs[x]] += add[x];
        s[rs[x]] *= tim[x];
        s[rs[x]] += add[x];
    }
    add[x] = 0, tim[x] = 1;
}
int merge(int x, int y) {
    if (!x || !y) return x ^ y;
    pushdown(x), pushdown(y);
    if (s[x] > s[y]) swap(x, y);
    rs[x] = merge(rs[x], y);
    if (dep[ls[x]] < dep[rs[x]]) swap(ls[x], rs[x]);
    dep[x] = dep[ls[x]] + 1;
    return x;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%lld", h + i), rt[i] = -1;
    Dep[1] = 1, dep[0] = -1;
    for (int i = 2; i <= n; i++) {
        scanf("%d%d%lld", fa + i, a + i, v + i);
        Dep[i] = Dep[fa[i]] + 1;
    }
    for (int i = 1; i <= m; i++) {
        scanf("%lld%d", s + i, c + i);
        tim[i] = 1;
        if (rt[c[i]] == -1) rt[c[i]] = i;
        else rt[c[i]] = merge(rt[c[i]], i);
    }
    for (int i = n; i >= 1; i--) {
        while (rt[i] != -1) {
            if (s[rt[i]] < h[i]) {
                die[rt[i]] = i;
                pushdown(rt[i]);
                if (!ls[rt[i]]) rt[i] = -1;
                else rt[i] = merge(ls[rt[i]], rs[rt[i]]);
            } else break;
        }
        if (i == 1) break;
        if (rt[i] == -1) continue;
        if (a[i]) tim[rt[i]] *= v[i], add[rt[i]] *= v[i], s[rt[i]] *= v[i];
        else add[rt[i]] += v[i], s[rt[i]] += v[i];
        pushdown(rt[i]);
        if (rt[fa[i]] == -1) rt[fa[i]] = rt[i];
        else rt[fa[i]] = merge(rt[fa[i]], rt[i]);
    }
    for (int i = 1; i <= m; i++) ans[die[i]]++;
    for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);
    for (int i = 1; i <= m; i++) printf("%d\n", Dep[c[i]] - Dep[die[i]]);
    return 0;
}

```
]]></description></item><item><title>HDU 5961 传递 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/20/hdu-5961.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 20 May 2020 08:37:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/20/hdu-5961.html</guid><description><![CDATA[# 题目

我们称一个有向图G是 传递的，当且仅当对任意三个不同的顶点a,,若G中有 一条边从a到b且有一条边从b到c ,则G中同样有一条边从a到c。
我们称图G是一个 竞赛图，当且仅当它是一个有向图且它的基图是完全图。换句 话说，将完全图每条边定向将得到一个竞赛图。
下图展示的是一个有4个顶点的竞赛图。

![](1.jpg)

现在，给你两个有向图$P=(V,E_p)$和$Q = (V,E_e)$，满足:
1. $E_P$与E_$e没有公共边；
2. $(V,E_p \cup E+e)$是一个竞赛图。
你的任务是：判定是否$P，Q$同时为传递的。

# 输入格式

包含至多20组测试数据。
第一行有一个正整数，表示数据的组数。
对于每组数据，第一行有一个正整数n。接下来n行，每行为连续的n个字符，每 个字符只可能是’-’,’P’,’Q’中的一种。
- 如果第i行的第j个字符为’P’，表示有向图P中有一条边从i到j;
- 如果第i行的第j个字符为’Q’，表示有向图Q中有一条边从i到j;
- 否则表示两个图中均没有边从i到j。
保证$1 <= n <= 2016$，一个测试点中的多组数据中的n的和不超过16000。保证输入的图一定满足给出的限制条件。

# 输出格式

对每个数据，你需要输出一行。如果P! Q都是传递的，那么请输出’T’。否则， 请输出’N’ (均不包括引号)。

# 输入样例

```cpp
4
4
-PPP
--PQ
---Q
----
4
-P-P
--PQ
P--Q
----
4
-PPP
--QQ
----
--Q-
4
-PPP
--PQ
----
--Q-
```

# 输出样例


```
T
N
T
N
```

# 题解

样例图

![](2.jpg)

注：在样例2中，P不是传递的。在样例4中，Q不是传递的。

假设$1->2,2->3$有边， 但$1->3$无边， 就不是传递的， 那么什么情况下$1->3$无边呢， 一种情况是$3->1$有边， 另一种情况是另一个图在$1,3$之间有边

第一种情况， $1->2,2->3,3->1$， 这显然是一个环

第二种情况， 当另一张图有$3->1$， 拼起来就构成一个环；当另一张图有$1->3$， 每条边反向拼起来也是一个环

所以使用拓扑排序找环即可。

# 代码

```c++
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
std::vector<int> edge[2017];
std::queue<int> Q;
int m, n, in[2017], cnt, newn;
int main() {
    scanf("%d", &n);
    while (n--) {
        scanf("%d", &m);
        memset(in, 0, sizeof(in));
        for (int i = 1; i <= m; i++) edge[i].clear();
        while (!Q.empty()) Q.pop();
        for (int i = 1; i <= m; ++i)
            for (int j = 1; j <= m; ++j) {
                char ch;
                scanf(" %c", &ch);
                if (ch == 'P') in[j]++, edge[i].push_back(j);
                else if (ch == 'Q') in[i]++, edge[j].push_back(i);
            }
        for (int i = 1; i <= m; i++) if (!in[i]) Q.push(i);
        cnt = 0;
        while (!Q.empty()) {
            newn = Q.front(), Q.pop(), cnt++;
            for (int i = 0; i < edge[newn].size(); i++) {
                in[edge[newn][i]]--;
                if (in[edge[newn][i]] == 0) Q.push(edge[newn][i]);
            }
        }
        puts((cnt == m)?"T":"N");
    }
}
```
]]></description></item><item><title>HDU 2157 How many ways?? 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/17/hdu-2157.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 17 May 2020 15:20:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/17/hdu-2157.html</guid><description><![CDATA[# 题目

春天到了, HDU校园里开满了花, 姹紫嫣红, 非常美丽. 葱头是个爱花的人, 看着校花校草竞相开放, 漫步校园, 心情也变得舒畅. 为了多看看这迷人的校园, 葱头决定, 每次上课都走不同的路线去教室, 但是由于时间问题, 每次只能经过k个地方, 比方说, 这次葱头决定经过$2$个地方, 那他可以先去问鼎广场看看喷泉, 再去教室, 也可以先到体育场跑几圈, 再到教室. 他非常想知道, 从$A$点恰好经过$k$个点到达$B$点的方案数, 当然这个数有可能非常大, 所以你只要输出它模上$1000$的余数就可以了. 你能帮帮他么?? 你可决定了葱头一天能看多少校花哦 

# 输入格式

输入数据有多组, 每组的第一行是2个整数 $n, m(0 < n <= 20, m <= 100)$ 表示校园内共有$n$个点, 为了方便起见, 点从$0$到$n-1$编号,接着有$m$行, 每行有两个整数 $s, t (0<=s,t < n)$ 表示从$s$点能到$t$点, 注意图是有向的.接着的一行是两个整数$T$,表示有$T$组询问$(1<=T<=100)$, 接下来的$T$行, 每行有三个整数 $A, B, k$, 表示问你从$A$点到$B$点恰好经过$k$个点的方案数 $(k < 20)$, 可以走重复边。如果不存在这样的走法, 则输出$0$

当$n$, $m$都为0的时候输入结束

# 输出格式

计算每次询问的方案数, 由于走法很多, 输出其对1000取模的结果

# 输入样例

```cpp
4 4
0 1
0 2
1 3
2 3
2
0 3 2
0 3 3
3 6
0 1
1 0
0 2
2 0
1 2
2 1
2
1 2 1
0 1 3
0 0
```
# 输出格式

```
2
0
1
3
```

# 题解

建立,邻接矩阵$Matrix$, 则$(Matrix^k)[i][j]$的值就是从$i$到$j$经过$k$个点的方法数, 所以矩阵乘法+快速幂解决

# 代码

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int mod = 1000;
struct Matrix {
    int data[22][22], row, col;
    Matrix operator*(Matrix b) {
        Matrix ans(row, b.col);
        memset(ans.data, 0, sizeof(ans.data));
        for (int i = 0; i < ans.row; i++)
            for (int k = 0; k < col; k++)
                if (data[i][k])
                    for (int j = 0; j < ans.col; j++) {
                        ans.data[i][j] += data[i][k] * b.data[k][j];
                        ans.data[i][j] %= mod;
                    }
        return ans;
    }
    Matrix operator^(int k) {
        Matrix ans(row, col), self = *this;
        for (int i = 0; i < row; i++)
            for (int j = 0; j < col; j++) ans.data[i][j] = (i == j);
        while (k) {
            if (k & 1) ans = ans * self;
            self = self * self, k >>= 1;
        }
        return ans;
    }
    Matrix(int r, int c) {
        memset(data, 0, sizeof(data));
        row = r, col = c;
    }
};
int main() {
    int n, m, T, a, b, k;
    while (scanf("%d%d", &n, &m), n + m) {
        Matrix A(n, n);
        while (m--) {
            int x, y;
            scanf("%d%d", &x, &y);
            A.data[x][y] = 1;
        }
        scanf("%d", &T);
        while (T--) {
            scanf("%d%d%d", &a, &b, &k);
            printf("%d\n", (A ^ k).data[a][b]);
        }
    }
    return 0;
}
```
]]></description></item><item><title>CF3D Least Cost Bracket Sequence 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/17/cf3D.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 17 May 2020 14:42:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/17/cf3D.html</guid><description><![CDATA[# 题目

This is yet another problem on regular bracket sequences.

A bracket sequence is called regular, if by inserting "+" and "1" into it we get a correct mathematical expression. For example, sequences "(())()", "()" and "(()(()))" are regular, while ")(", "(()" and "(()))(" are not. You have a pattern of a bracket sequence that consists of characters "(", ")" and "?". You have to replace each character "?" with a bracket so, that you get a regular bracket sequence.

For each character "?" the cost of its replacement with "(" and ")" is given. Among all the possible variants your should choose the cheapest.


给一个序列，序列里面会有左括号、问号、右括号。对于一个?而言，可以将其替换为一个(，也可以替换成一个)，但是都有相应的代价。问：如何替换使得代价最小。前提是替换之后的序列中，括号是匹配的。如果不能替换为一个括号匹配的序列则输出-1。

# 输入格式

The first line contains a non-empty pattern of even length, consisting of characters "(", ")" and "?". Its length doesn't exceed $5·10^4$. Then there follow $m$ lines, where $m$ is the number of characters "?" in the pattern. Each line contains two integer numbers $a_i$ and $b_i (1 ≤ a_i,  b_i ≤ 10^6)$, where $a_i$ is the cost of replacing the i-th character "?" with an opening bracket, and $b_i$ — with a closing one.

第一行是序列，序列长度不超过50000，下面m(m是?的数量)行有每行2个数据，第一个是(的代价，第2个是)的代价

# 输出格式

Print the cost of the optimal regular bracket sequence in the first line, and the required sequence in the second.

Print -1, if there is no answer. If the answer is not unique, print any of them.

第一行打印代价，第二行打印替换后的序列。不行输出-1

# 样例输入

```
(??)
1 2
2 8
```

# 样例输出

```
4
()()
```

# 题解

使用贪心

先把每个?变成右括号，如果这时候发现这个右括号没有左括号和它匹配，就从当前位置往前在所有没变成左括号的?中选择变为左括号产生的花费最少的一个,转成左括号.

写代码的时候, 扫描每个?,将它赋值为左括号, 然后将其加入优先队列, 找花费最少的时候, 直接从优先队列里找

如果最后还是存在未匹配的括号，就是无解的情况.

另外统计价值之和时要开long long.

# 代码

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
const int MAXN = 50005;
char s[MAXN];
int n, lb, rb;
struct Node {
    int i, l, r;
    bool operator<(const Node &other) const { return r - l < other.r - other.l; }
};
std::priority_queue<Node> pq;
int main() {
    scanf("%s", s + 1);
    n = strlen(s + 1);
    int cnt = 0;
    long long sum = 0;
    for (int i = 1; i <= n; i++) {
        if (s[i] == '(') cnt++;
        if (s[i] == '?') {
            scanf("%d%d", &lb, &rb);
            if (i == 1) {
                sum += lb;
                s[i] = '(';
                cnt++;
                continue;
            }
            sum += rb;
            s[i] = ')';
            pq.push((Node){i, lb, rb});
        }
        if (s[i] == ')') {
            if (cnt == 0) {
                if (pq.empty()) return puts("-1"), 0;
                Node t = pq.top();
                pq.pop();
                if (t.i == n) t = pq.top(), pq.pop();
                sum = sum - t.r + t.l;
                s[t.i] = '(';
                cnt += 2 - (t.i == i);
            }
            if (s[i] == ')') cnt--;
        }
    }
    if (cnt != 0)puts("-1");
    else printf("%lld\n%s", sum, s + 1);
    return 0;
}
```
]]></description></item><item><title>POJ 3057 Evacuation 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/15/poj-3057.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 15 May 2020 14:00:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/15/poj-3057.html</guid><description><![CDATA[# 题目

Fires can be disastrous, especially when a fire breaks out in a room that is completely filled with people. Rooms usually have a couple of exits and emergency exits, but with everyone rushing out at the same time, it may take a while for everyone to escape.

You are given the floorplan of a room and must find out how much time it will take for everyone to get out. Rooms consist of obstacles and walls, which are represented on the map by an 'X', empty squares, represented by a '.' and exit doors, which are represented by a 'D'. The boundary of the room consists only of doors and walls, and there are no doors inside the room. The interior of the room contains at least one empty square.

Initially, there is one person on every empty square in the room and these persons should move to a door to exit. They can move one square per second to the North, South, East or West. While evacuating, multiple persons can be on a single square. The doors are narrow, however, and only one person can leave through a door per second.

What is the minimal time necessary to evacuate everybody? A person is evacuated at the moment he or she enters a door square.

# 输入格式

The first line of the input contains a single number: the number of test cases to follow. Each test case has the following format:
One line with two integers $Y$ and $X$, separated by a single space, satisfying $3 <= Y, X <= 12$: the size of the room
$Y$ lines with $X$ characters, each character being either 'X', '.', or 'D': a valid description of a room

# 输出格式

For every test case in the input, the output should contain a single line with the minimal evacuation time in seconds, if evacuation is possible, or "impossible", if it is not.

#　样例输入

```
3
5 5
XXDXX
X...X
D...X
X...D
XXXXX
5 12
XXXXXXXXXXXX
X..........D
X.XXXXXXXXXX
X..........X
XXXXXXXXXXXX
5 5
XDXXX
X.X.D
XX.XX
D.X.X
XXXDX
```

# 样例输出

```
3
21
impossible
```

#　题解

这道题要用二分图的最大匹配来做

对于每一扇门，同一秒只能让一个人通过，那我们就为每一扇门在每一秒建一个节点。

对于每一个人，假设他最快可以在 $t$ 的时间到达门 $i$，那就把$t$到最大时间(图的大小) 这些节点建边连到人 $j$。

如果在这个图上跑二分匹配，匹配的边 <$t$时的门$i$, 人$j$> 就代表人 $j$ 会在时间 $t$ 时从门 $i$ 逃脱。

找最短时间, 不断地枚举点，从该点找增广路。当从时间小的门的点开始枚举，这就代表时间小的门会优先匹配。我们只需看看枚举到哪个时间的门的时候，总匹配数等于人的数量，也是就所有人都被匹配到时，程序就可以结束了。答案就是此时的时间。

实现的时候， 可以从每个门做一次 bfs，来找各个人到各个点所需的时间

# 代码

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
int V, X, Y, dxy[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
char map[13][13];
vector<int> G[50010], dx, dy, px, py;
int match[50005], dist[13][13][13][13];
bool vis[50005];
void add(int u, int v) { G[u].push_back(v), G[v].push_back(u); }
bool find(int v) {
    vis[v] = 1;
    for (int i = 0; i < G[v].size(); i++) {
        int u = G[v][i];
        if (match[u] == -1 || !vis[match[u]] && find(match[u]))
            return match[v] = u, match[u] = v, true;
    }
    return false;
}
void bfs(int x, int y, int d[13][13]) {
    queue<int> qx, qy;
    d[x][y] = 0;
    qx.push(x), qy.push(y);
    while (!qx.empty()) {
        x = qx.front(), qx.pop();
        y = qy.front(), qy.pop();
        for (int k = 0; k < 4; k++) {
            int nx = x + dxy[k][0], ny = y + dxy[k][1];
            if (0 <= nx && nx < X && 0 <= ny && ny < Y && map[nx][ny] == '.' && d[nx][ny] < 0) {
                d[nx][ny] = d[x][y] + 1;
                qx.push(nx), qy.push(ny);
            }
        }
    }
}
int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        scanf("%d%d", &X, &Y);
        for (int i = 0; i < X; i++) scanf("%s", map[i]);
        int n = X * Y;
        dx.clear(), dy.clear(), px.clear(), py.clear();
        memset(dist, -1, sizeof(dist));
        for (int x = 0; x < X; x++)
            for (int y = 0; y < Y; y++) {
                if (map[x][y] == 'D') {
                    dx.push_back(x), dy.push_back(y), bfs(x, y, dist[x][y]);
                } else if (map[x][y] == '.')
                    px.push_back(x), py.push_back(y);
            }
        int d = dx.size(), p = px.size();
        V = X * Y * d + p;
        for (int v = 0; v < V; ++v) G[v].clear();
        for (int i = 0; i < d; i++)
            for (int j = 0; j < p; j++)
                if (dist[dx[i]][dy[i]][px[j]][py[j]] >= 0)
                    for (int k = dist[dx[i]][dy[i]][px[j]][py[j]]; k <= n; k++)
                        add((k - 1) * d + i, n * d + j);
        if (p == 0) {
            puts("0");
            continue;
        }
        int res = 0, flag = 1;
        memset(match, -1, sizeof(match));
        for (int v = 0; v < n * d; v++) {
            memset(vis, 0, sizeof(vis));
            if (find(v) && ++res == p) {
                printf("%d\n", v / d + 1);
                flag = 0;
                break;
            }
        }
        if(flag)puts("impossible");
    }
}
```
]]></description></item><item><title>POJ 3263 Tallest Cow 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/15/poj-3263.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 15 May 2020 11:20:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/15/poj-3263.html</guid><description><![CDATA[#　题目

FJ's $N (1 ≤ N ≤ 10,000)$ cows conveniently indexed 1..N are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height $H (1 ≤ H ≤ 1,000,000)$ of the tallest cow along with the index I of that cow.

FJ has made a list of $R (0 ≤ R ≤ 10,000)$ lines of the form "cow 17 sees cow 34". This means that cow 34 is at least as tall as cow 17, and that every cow between 17 and 34 has a height that is strictly smaller than that of cow 17.

For each cow from 1..N, determine its maximum possible height, such that all of the information given is still correct. It is guaranteed that it is possible to satisfy all the constraints.

# 输入格式

Line 1: Four space-separated integers: $N, I, H and R$
Lines 2..R+1: Two distinct space-separated integers $A and B (1 ≤ A, B ≤ N)$, indicating that cow $A$ can see cow $B$.

#　输出格式

Lines $1..N$: Line i contains the maximum possible height of cow $i$.

# 题解

首先假设每头牛都和最高的牛一样高, 然后输入两个数$a,b$, $a,b$之间的牛都比$a,b$低, 但由于要每头牛尽可能高, 所以都是低$1$, 用差分就能完成,$a+1$的位置$-1$,$b$的位置$+1$, 输出的时候, 输出前缀和加上最高牛的高度即可.

有一点要注意, 如果一个相同的区间输入两次, 就会多计算一次, $a,b$之间的牛高度就会$-2$, 所以要排序去重, 但是奇怪的是, 如果你不排序, 光去重, 也能A

比如这个代码:

```c++
#include <cstdio>
int N, H, R, cow[100005], p[100005][2];
int main() {
    int a, b;
    scanf("%d%*d%d%d", &N, &H, &R);
    for (int i = 0; i < R; i++) {
        scanf("%d%d", &a, &b);
        p[i][0] = (a > b) ? b : a, p[i][1] = (a > b) ? a : b;
    }
    for (int i = 0; i < R; i++)
        if (!i || p[i][0] != p[i - 1][0] || p[i][1] != p[i - 1][1])
            cow[p[i][0] + 1]--, cow[p[i][1]]++;
    for (int i = 1, d = 0; i <= N; i++) printf("%d\n", (d += cow[i]) + H);
    return 0;
}
```

但是如果不排序, 不去重又会WA, 所以只能理解为输入数据把相同的都放在了一起...

# 代码

加了排序的正解

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
int N, H, R, cow[100005];
pair<int, int> p[100005];
int main() {
    int a, b;
    scanf("%d%*d%d%d", &N, &H, &R);
    for (int i = 0; i < R; i++) {
        scanf("%d%d", &a, &b);
        p[i].first = (a > b) ? b : a, p[i].second = (a > b) ? a : b;
    }
    sort(p, p + R);
    for (int i = 0; i < R; i++)
        if (!i || p[i].first != p[i - 1].first || p[i].second != p[i - 1].second)
            cow[p[i].first + 1]--, cow[p[i].second]++;
    for (int i = 1, d = 0; i <= N; i++)
        printf("%d\n", ( d += cow[i] ) + H);
    return 0;
}
```
]]></description></item><item><title>HAOI2012 容易题</title><link>http://www.cnblogs.com/youxam/archive/2020/05/13/haoi-2012.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 13 May 2020 12:32:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/13/haoi-2012.html</guid><description><![CDATA[# 题目

为了使得大家高兴，小Q特意出个自认为的简单题（easy）来满足大家，这道简单题是描述如下：
有一个数列A已知对于所有的$A[i]$都是1~n的自然数，并且知道对于一些$A[i]$不能取哪些值，我们定义一个数列的积为该数列所有元素的乘积，要求你求出所有可能的数列的积的和 $mod 1000000007$的值，是不是很简单呢？呵呵！

#　输入格式


第一行三个整数$n,m,k$分别表示数列元素的取值范围，数列元素个数，以及已知的限制条数。
接下来$k$行，每行两个正整数$x,y$表示$A[x]$的值不能是$y$。

# 输出格式

一行一个整数表示所有可能的数列的积的和对$1000000007$取模后的结果。如果一个合法的数列都没有，答案输出$0$。

# 输入样例

```
3 4 5
1 1
1 1
2 2
2 3
4 3
```

# 输出样例

```
90
```

#　样例解释

$A[1]$不能取1
$A[2]$不能取2、3
$A[4]$不能取3
所以可能的数列有以下12种
```
数列        积
2 1 1 1     2
2 1 1 2     4
2 1 2 1     4
2 1 2 2     8
2 1 3 1     6
2 1 3 2     12
3 1 1 1     3
3 1 1 2     6
3 1 2 1     6
3 1 2 2     12
3 1 3 1     9
3 1 3 2     18
```

# 数据范围


数据范围

30%的数据$n \le 4,m \le 10,k \le 10$

另有20%的数据$k=0$

70%的数据$n\le1000,m\le 1000,k\le 1000$

100%的数据$n\le 109,m\le 10^9,k\le 10^5,1\le y\le n,1\le x\le m$

# 题解

若无限制, 每个位置都可以选择$1-n$, 答案自然是

$(1+2+3+4+5+\dots+n)^m$

如果加入了限制, 第$x$位不能选$y$, 那么答案就会减少其它位之积乘$y$.

注意, 样例中存在$x,y$都相等的两次输入, 所以需要用map去重, 否则会多减

# 代码

```
#include <bits/stdc++.h>
using namespace std;
struct A {
    int a, b;
    bool operator>(A y) const { return (a != y.a) ? a > y.a : b > y.b;}
    bool operator<(A y) const { return (a != y.a) ? a < y.a : b < y.b; }
};
const long long mod = 1e9 + 7;
long long n, m, k, sum[100010], ans, v;
int id, t, cnt;
map<int, int> ma;
map<A, bool> mb;
long long pow(long long x, long long y) {
    long long tot = 1;
    while (y) {
        if (y & 1) tot = tot * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return tot;
}
long long f2(long long x) { return pow(x % mod, mod - 2); }
long long f1(long long x, long long y) { return x % mod * f2(y) % mod; }
int main() {
    scanf("%lld%lld%lld", &n, &m, &k);
    ans = pow(n * (n + 1) / 2 % mod, m);
    for (int i = 1; i <= k; i++) sum[i] = n * (n + 1) / 2;
    for (int i = 1; i <= k; i++) {
        scanf("%d%lld", &id, &v);
        t = ma[id];
        if (!t) t = ma[id] = ++cnt;
        if (mb.count((A){t, (int)v})) continue;
        mb[(A){t, (int)v}] = 1;
        ans = (ans - f1(ans, sum[t]) * v % mod + mod) % mod;
        sum[t] = (sum[t] - v + mod) % mod;
    }
    printf("%lld", ans);
    return 0;
}
```
]]></description></item><item><title>HDU 2236 无题II 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/12/hdu-2236.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Tue, 12 May 2020 12:08:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/12/hdu-2236.html</guid><description><![CDATA[# 题目

这是一个简单的游戏，在一个n*n的矩阵中，找n个数使得这n个数都在不同的行和列里并且要求这n个数中的最大值和最小值的差值最小。

# 输入格式

输入一个整数$T$表示$T$组数据。

对于每组数据第一行输入一个正整数$n(1<=n<=100)$表示矩阵的大小。

接着输入$n$行，每行$n$个数$x(0<=x<=100)$。

# 输出格式

对于每组数据输出一个数表示最小差值。

#　输入样例

```
1
4
1 1 1 1
2 2 2 2
3 3 3 3
4 4 4 4
```

#　输出格式

3

# 题解

二分答案， 二分差值， 每次用匈牙利算法检查是否合法，合法就增加差值， 不合法就减少差值， 找到最大且合法的差值

# 代码

```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int N = 101;
int n, a[N][N], match[N], T;
bool vis[N];
bool dfs(int u, int l, int r) {
    for (int v = 1; v <= n; v++) {
        if (a[u][v] >= l && a[u][v] <= r && !vis[v]) {
            vis[v] = true;
            if (match[v] == -1 || dfs(match[v], l, r)) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}
bool hungry(int mid, int l, int r) {
    int res = 0;
    memset(match, -1, sizeof(match));
    for (int u = 1; u <= n; u++) {
        memset(vis, 0, sizeof(vis));
        if (!dfs(u, l, r)) return false;
    }
    return true;
}
bool check(int mid) {
    for (int i = 0; i + mid <= 100; i++)
        if (hungry(mid, i, i + mid))return true;
    return false;
}
int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        int minv = inf, maxv = -1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++) {
                scanf("%d", &a[i][j]);
                minv = min(minv, a[i][j]);
                maxv = max(maxv, a[i][j]);
            }
        int l = 0, r = maxv - minv;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (check(mid)) r = mid - 1;
            else l = mid + 1;
        }
        printf("%d\n", l);
    }
    return 0;
}
```]]></description></item><item><title>UVA 11383 Golden Tiger Claw 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/10/uva-11383.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 10 May 2020 14:42:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/10/uva-11383.html</guid><description><![CDATA[# 题目

<!--
<iframe src="https://vj.z180.cn/4e39219962c26630eedfd16bd0f10790?v=1588805623#view=FitH" style="width:100%; height:1400px;" frameborder="0"></iframe>
-->

# 题解

其实就是一个KM的板子

KM算法在进行中, 需要满足两个点的顶标值之和大于等于两点之间的边权, 所以进行一次KM即可.

KM之后, 顶标之和就是最小的。因为如果不是最小的，就能通过修改顶标值来使某对顶点的顶标值满足$wx[i]+ly[j]==w[i][j]$，这样相等子图中又会多一条边，但此时已全部匹配，所以是最小的。

#　代码

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#define N 510
using namespace std;
const int inf = 1 << 30;
int s[N][N], lx[N], ly[N], match[N], slack[N], n;
bool vx[N], vy[N];
bool dfs(int u) {
    vx[u] = 1;
    for (int i = 1; i <= n; i++) {
        if (!vy[i]) {
            int t = lx[u] + ly[i] - s[u][i];
            if (t == 0) {
                vy[i] = 1;
                if (match[i] == -1 || dfs(mat[i])) {
                    match[i] = u;
                    return 1;
                }
            } else
                slack[i] = min(slack[i], t);
        }
    }
    return 0;
}
void KM() {
    memset(match, -1, sizeof(match));
    memset(ly, 0, sizeof(ly));
    for (int i = 1; i <= n; i++) {
        lx[i] = -inf;
        for (int j = 1; j <= n; j++) lx[i] = max(lx[i], s[i][j]);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) slack[j] = inf;
        while (1) {
            memset(vx, 0, sizeof(vx));
            memset(vy, 0, sizeof(vy));
            if (dfs(i)) break;
            int d = inf;
            for (int j = 1; j <= n; j++)
                if (!vy[j]) d = min(d, slack[j]);
            for (int j = 1; j <= n; j++)
                if (vx[j]) lx[j] -= d;
            for (int j = 1; j <= n; j++)
                if (vy[j]) ly[j] += d;
        }
    }
    int ans = 0;
    for (int i = 1; i < n; i++) {
        printf("%d ", lx[i]);
        ans += lx[i];
    }
    printf("%d\n", lx[n]);
    ans += lx[n];
    for (int i = 1; i < n; i++) {
        printf("%d ", ly[i]);
        ans += ly[i];
    }
    printf("%d\n", ly[n]);
    ans += ly[n];
    printf("%d\n", ans);
}
int main() {
    while (~scanf("%d", &n)) {
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++) scanf("%d", &s[i][j]);
        KM();
    }
    return 0;
}
```]]></description></item><item><title>Xor_Sum 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/09/xor-sum.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sat, 09 May 2020 13:45:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/09/xor-sum.html</guid><description><![CDATA[# 题目

You are given a positive integer $N(1≦N≦10^{18})$. Find the number of the pairs of integers $u$ and $v (0≦u,v≦N)$ such that there exist two non-negative integers $a$ and $b$ satisfying $a xor b=u$ and $a+b=v$. Here, $xor$ denotes the bitwise exclusive OR. Since it can be extremely large, compute the answer modulo $10^9+7$.

给出正整数$N$,求出整数对$u$和$v (0≤u,v≤N)$的数目，使得存在两个非负整数$a$和$b$满足$a xor b = u$ 和$a + b= v$。这里，$xor$表示按位异或。对答案取模$10^9 + 7$

#　输入格式

The input is given from Standard Input in the following format:　$N$

一个整数$N$

#　输出格式

Print the number of the possible pairs of integers $u$ and $v$ ,modulo $10^9+7$.

$u,v$对的数量模$10^9+7$

#　输入样例

```
3
```

# 输出样例

```
5
```

# 题解

把$n=1,2,3,4,5...$的答案手算出来, 是`1, 2, 4, 5, 8, 10, 13, 14, 18, 21, 26, 28, 33, 36, 40, 41, 46, 50, 57, 60...`然后找规律, 如果不好找, 可以在[这个网站](http://oeis.org/?language=chineseS)搜索.

用记忆化搜索优化效率, 如果开数组开不下, 用map即可

~~我怀疑这个不是正解~~

# 代码

```cpp
#include <cstdio>
#include <map>
const long long MOD = 1e9 + 7;
std::map<long long, long long> dp;
long long f(long long x) {
    if (dp[x]) return dp[x] % MOD;
    return dp[x] = (f((x - 1) / 2) + f(x / 2) + f((x - 2) / 2)) % MOD;
}
int main() {
    long long n;
    scanf("%lld", &n);
    dp[0] = 1;
    dp[1] = 2;
    printf("%lld\n", f(n) % MOD);
}
```]]></description></item><item><title>CF1051F The Shortest Statement 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/08/cf1051F.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 08 May 2020 14:24:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/08/cf1051F.html</guid><description><![CDATA[#　题目

You are given a weighed undirected connected graph, consisting of n vertices and m edges.

You should answer q queries, the i-th query is to find the shortest distance between vertices $u＿i$ and $v_i$.

# 输入格式

The first line contains two integers $n$ and $m (1≤n,m≤105,m−n≤20)$ — the number of vertices and edges in the graph.

Next m lines contain the edges: the i-th edge is a triple of integers $v_i,u_i,d_i (1≤u_i,v_i≤n,1≤d_i≤10^9,u_i≠v_i)$. This triple means that there is an edge between vertices ui and vi of weight di. It is guaranteed that graph contains no self-loops and multiple edges.

The next line contains a single integer $q (1≤q≤10^5)$ — the number of queries.

Each of the next q lines contains two integers $u_i$ and $v_i (1≤u_i,v_i≤n)$ — descriptions of the queries.

Pay attention to the restriction $m−n ≤ 20$.

#　输出格式

Print q lines.

The i-th line should contain the answer to the i-th query — the shortest distance between vertices $u_i$ and $v_i$.

# 输入样例1

```
3 3
1 2 3
2 3 1
3 1 5
3
1 2
1 3
2 3
```

# 输出样例1

```
3
4
1
```

# 输入样例2

```
8 13
1 2 4
2 3 6
3 4 1
4 5 12
5 6 3
6 7 8
7 8 7
1 4 1
1 8 3
2 6 9
2 7 1
4 6 3
6 8 2
8
1 5
1 7
2 3
2 8
3 7
3 4
6 8
7 8
```

# 输出样例2

```
7
5
6
7
7
1
2
7
```

# 题解

由于$m−n ≤ 20$, 边和点的数量接近, 所以大部分最短路用lca解决, 剩下的一些没有计算的边, 对它们的顶点重新跑一遍最短路, 然后枚举每一个点, 更新两个目标点之间的最短距离.

# 代码

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
const long long INF = 1e18;
const int N = 100005;
int head[N], tote, f[N][21], deth[N], tmp[100], tot, n, m;
long long dis[N], d[50][N];
bool vis[N];
struct Edge { int to, next, value; } edges[N << 1];
void add(int u, int v, int w) {
    edges[++tote]= (Edge){ v, head[u], w}, head[u] = tote;
    edges[++tote]= (Edge){ u, head[v], w}, head[v] = tote;
}
priority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > q;
void dijkstra(int id, int S) {
    for (int i = 1; i <= n; ++i) dis[i] = INF, vis[i] = false;
    dis[S] = 0;
    q.push(make_pair(0, S));
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (int i = head[u]; i; i = edges[i].next) {
            int v = edges[i].to;
            if (dis[v] > dis[u] + edges[i].value) {
                dis[v] = dis[u] + edges[i].value;
                q.push(make_pair(dis[v], v));
            }
        }
    }
    for (int i = 1; i <= n; ++i) d[id][i] = dis[i];
}
void dfs(int u, int fa) {
    vis[u] = true;
    f[u][0] = fa;
    deth[u] = deth[fa] + 1;
    for (int i = head[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v == fa) continue;
        if (vis[v]) tmp[++tot] = u, tmp[++tot] = v;
        else dis[v] = dis[u] + edges[i].value, dfs(v, u);
    }
}
int lca(int u, int v) {
    if (deth[u] < deth[v]) swap(u, v);
    int d = deth[u] - deth[v];
    for (int i = 20; i >= 0; --i)
        if (d & (1 << i)) u = f[u][i];
    if (u == v) return u;
    for (int i = 20; i >= 0; --i)
        if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
    return f[u][0];
}
inline int input() { int t; scanf("%d", &t); return t; }
int main() {
    n = input(), m = input();
    for (int i = 1; i <= m; ++i){
        int u = input(), v = input(), w = input();
        add(u, v, w);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; ++i) d[0][i] = dis[i];
    for (int j = 1; j <= 20; ++j)
        for (int i = 1; i <= n; ++i) f[i][j] = f[f[i][j - 1]][j - 1];
    sort(tmp + 1, tmp + tot + 1);
    int j = 1;
    for (int i = 2; i <= tot; ++i)
        if (tmp[j] != tmp[i]) tmp[++j] = tmp[i];
    for (int i = 1; i <= j; ++i) dijkstra(i, tmp[i]);
    for(int q = input(); q; q--) {
        int u = input(), v = input();
        long long ans = d[0][u] + d[0][v] - 2 * d[0][lca(u, v)];
        for (int i = 1; i <= j; ++i) ans = min(ans, d[i][u] + d[i][v]);
        printf("%lld\n", ans);
    }
    return 0;
}
```
]]></description></item><item><title>CF819B Mister B and PR Shifts 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/08/cf819B.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 08 May 2020 12:11:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/08/cf819B.html</guid><description><![CDATA[# 题目

Some time ago Mister B detected a strange signal from the space, which he started to study.

After some transformation the signal turned out to be a permutation p of length n or its cyclic shift. For the further investigation Mister B need some basis, that's why he decided to choose cyclic shift of this permutation which has the minimum possible deviation.

Let's define the deviation of a permutation p as $\Sigma^{i=n}_{i=1}|p[i]-i|$.

Find a cyclic shift of permutation p with minimum possible deviation. If there are multiple solutions, print any of them.

Let's denote id k $(0 ≤ k < n)$ of a cyclic shift of permutation p as the number of right shifts needed to reach this shift, for example:

$k = 0: shift\ \ p_1, p_2, ... p_n,$
$k = 1: shift\ \ p_n, p_1, ... p_{n - 1},$
$...$
$k = n - 1: shift\ \ p_2, p_3, ... p_n, p_1.$

# 输入格式

First line contains single integer $n (2 ≤ n ≤ 106)$ — the length of the permutation.

The second line contains n space-separated integers $p_1, p_2, ..., p_n (1 ≤ p_i ≤ n)$ — the elements of the permutation. It is guaranteed that all elements are distinct.

# 输出格式

Print two integers: the minimum deviation of cyclic shifts of permutation p and the id of such shift. If there are multiple solutions, print any of them.

# 样例

## 输入1

```
3
1 2 3
```

## 输出１

```
0 0
```

## 输入2

```
3
2 3 1
```

## 输出2

```
0 1
```

## 输入33
```
3
3 2 1
```

## 输出3

```
2 1
```

# 题解

如果纯模拟, 真的移动$n$次, 再加起来计算最小值, 复杂度太高, 需要一个$O(n)$的方法

很显然, 每次移动一位, 下标之间相差1, 可以看出规律来, 就是$p[i]$不变, 每次$i$增加$1$, 超出范围的置为$1$, 

$p[i] < i$时, 随着移动, $i$逐渐变大, $|p[i] - i|=i-p[i]$逐渐变大, 当$i$超过$n$时, 重置为$1$, 有可能变成第二种状态

$p[i] > i$时, 随着移动, $i$逐渐变大,$|p[i] - i|=p[i] - i$逐渐变小, 当移动到$p[i] = i$时, 转为第三种状态, 先记录下来$p[i]$与$i$最初的距离, 当移动次数与距离相等时, 转换状态

$p[i] = i$时, $|p[i] - i|=0$, 再移动将会转为第一种状态.

最开始计算出所有数字之和, 根据移动次数, 处于三个状态的数字个数即可直接计算出现在的$\Sigma^{i=n}_{i=1}|p[i]-i|$

$n$次循环中, 取最小值输出

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 5;
long long p[maxn], has[maxn << 1];
int main() {
    long long n, bigger = 0, smaller = 0, equ = 0, ans1 = 0, ans2 = 0;
    scanf("%lld", &n);
    for (long long i = 1ll; i <= n; i++) {
        scanf("%lld", &p[i]);
        if (p[i] > i) bigger++, has[p[i] - i]++;
        else if (p[i] == i) equ++, has[0]++;
        else smaller++;
        ans1 += abs(p[i] - i);
    }
    long long temp = ans1;
    for (long long last = n - 1ll, delta = 1ll; last >= 1ll; last--, delta++) {
        temp += equ + smaller - bigger;
        smaller += equ;
        bigger -= has[delta];
        if (p[last + 1] >= last + 1ll) has[p[last + 1] - last - 1]--;
        has[p[last + 1] - 1 + delta]++;
        equ = has[delta];
        if (p[last + 1] > 1ll) bigger++;
        smaller = n - equ - bigger;
        temp -= abs(p[last + 1] - n - 1ll) - abs(p[last + 1] - 1ll);
        if (temp < ans1) ans1 = temp, ans2 = delta;
    }
    printf("%lld %lld\n", ans1, ans2);
    return 0;
}
```
]]></description></item><item><title>HDU3686 Traffic Real Time Query System 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/06/hdu3686.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 06 May 2020 14:22:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/06/hdu3686.html</guid><description><![CDATA[#　题目

City C is really a nightmare of all drivers for its traffic jams. To solve the traffic problem, the mayor plans to build a RTQS (Real Time Query System) to monitor all traffic situations. City C is made up of N crossings and M roads, and each road connects two crossings. All roads are bidirectional. One of the important tasks of RTQS is to answer some queries about route-choice problem. Specifically, the task is to find the crossings which a driver MUST pass when he is driving from one given road to another given road.

# 输入格式

There are multiple test cases.
For each test case:
The first line contains two integers $N$ and $M$, representing the number of the crossings and roads.
The next M lines describe the roads. In those M lines, the i th line (i starts from 1)contains two integers $X_i$ and $Y_i$, representing that road i connects crossing $X_i$ and $Y_i$ ($X_i≠Y_i$).
The following line contains a single integer Q, representing the number of RTQs.
Then Q lines follows, each describing a RTQ by two integers $S$ and $T(S≠T)$ meaning that a driver is now driving on the roads and he wants to reach roadt . It will be always at least one way from roads to roadt.
The input ends with a line of “0 0”.
Please note that: $0< N \le 10000$, $0 < M \le 100000$, $0 < Q \le 10000$, $0 < X_i$,$Y_i \le N$, $0 < S,T \le M$

# 输出格式

For each RTQ prints a line containing a single integer representing the number of crossings which the driver MUST pass.

#　样例输入

```
5 6
1 2
1 3
2 3
3 4
4 5
3 5
2
2 3
2 4
0 0
```

#　样例输出

```
0
1
```

# 题解 

题目大意:

输出两条边之间必须经过的点

这道题其实没有什么思维难度, 显然先缩点, 求lca即可.

主要就是调起来很麻烦, 而且起点和终点不是点是边.

tarjon缩点, 倍增求lca

# 代码

```cpp
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 1e4 + 5, M = 1e5 + 5, Lg = 25;
int n, m, qn, tot, head[2][N << 1], top, sta[N], dfsc, dfn[N], low[N], dccCnt, root, bel[N], eb[M], fa[N << 1][Lg], dep[N << 1], id[N];
bool cut[N], vis[N << 1];
vector<int> dcc[N];
struct Edge { int to, nxt, id; } edges[M << 2];
inline void add(int type, int from, int to, int eid) {
    edges[++tot] = (Edge){to, head[type][from], eid}, head[type][from] = tot;
}
void tarjan(int x) {
    dfn[x] = low[x] = ++dfsc;
    sta[++top] = x;
    if (x == root && head[0][x] == 0)
        return dcc[++dccCnt].push_back(x);
    int son = 0;
    for (int i = head[0][x]; i; i = edges[i].nxt) {
        int y = edges[i].to;
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
            if (dfn[x] <= low[y]) {
                son++;
                if (x != root || son > 1) cut[x] = 1;
                dccCnt++;
                while(1){
                    int z = sta[top--];
                    dcc[dccCnt].push_back(z);
                    if (z == y) break;
                }
                dcc[dccCnt].push_back(x);
            }
        } else low[x] = min(low[x], dfn[y]);
    }
}
void dfs(int x, int fat, int depth) {
    vis[x] = 1, fa[x][0] = fat, dep[x] = depth;
    for (int i = 1; i <= 15; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];
    for (int i = head[1][x]; i; i = edges[i].nxt) {
        int y = edges[i].to;
        if (vis[y]) continue;
        dfs(y, x, depth + 1);
    }
}
int lca(int x, int y) {
    if (dep[x] < dep[y]) swap(x, y);
    for (int i = 15; i >= 0; i--)
        if (dep[fa[x][i]] >= dep[y]) x = fa[x][i];
    if (x == y) return x;
    for (int i = 15; i >= 0; i--)
        if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}
int main() {
    while (1) {
        scanf("%d%d", &n, &m);
        if (n == 0 && m == 0) break;
        tot = dfsc = dccCnt = top = 0;
        memset(head, 0, sizeof(head));
        memset(dfn, 0, sizeof(dfn));
        memset(low, 0, sizeof(low));
        memset(cut, 0, sizeof(cut));
        for (int x, y, i = 1; i <= m; i++) {
            scanf("%d%d", &x, &y);
            add(0, x, y, i), add(0, y, x, i);
        }
        for (int i = 1; i <= n; i++) dcc[i].clear();
        for (int i = 1; i <= n; i++)
            if (!dfn[i]) tarjan(root = i);
        int now = dccCnt;
        for (int i = 1; i <= n; i++)
            if (cut[i]) id[i] = ++now;
        for (int i = 1; i <= dccCnt; i++) {
            for (int j = 0; j < dcc[i].size(); j++) {
                int x = dcc[i][j];
                if (cut[x]) add(1, id[x], i, 0), add(1, i, id[x], 0);
                bel[x] = i;
            }
            for (int j = 0; j < dcc[i].size(); j++)
                for (int k = head[0][dcc[i][j]]; k; k = edges[k].nxt) if (bel[edges[k].to] == i) eb[edges[k].id] = i;
        }
        memset(dep, 0, sizeof(dep));
        memset(fa, 0, sizeof(fa));
        memset(vis, 0, sizeof(vis));
        for (int i = 1; i <= now; i++) if (!vis[i]) dfs(i, 0, 1);
        scanf("%d", &qn);
        for (int x, y; qn--;) {
            scanf("%d%d", &x, &y);
            x = eb[x], y = eb[y];
            if (x == y) puts("0");
            else printf("%d\n", (dep[x] + dep[y] - 2 * dep[lca(x, y)]) / 2);
        }
    }
    return 0;
}
```]]></description></item><item><title>HDU 5969 最大的位或 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/06/hdu5969.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 06 May 2020 12:00:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/06/hdu5969.html</guid><description><![CDATA[#　题目

B君和G君聊天的时候想到了如下的问题。
给定自然数l和r ,选取2个整数$x,y$满足$l <= x <= y <= r$,使得$x|y$最大。
其中$|$表示按位或，即$C、 C++、 Java$中的$|$运算。

# 输入格式

包含至多$10001$组测试数据。
第一行有一个正整数，表示数据的组数。
接下来每一行表示一组数据，包含两个整数$l,r$。
保证 $0 <= l <= r <= 1018$。

#　输出格式

对于每组数据输出一行，表示最大的位或。

# 输入样例

```
5
1 10
0 1
1023 1024
233 322
1000000000000000000 1000000000000000000
```

# 输出样例

```
15
1
2047
511
1000000000000000000
```

# 题解

输入两个数字$l,r$

二进制位低位对齐, 从高位向低位遍历.

1. 如果两个数字第$i$位不相同, 那答案从这一位开始, 到最后都是$1$, 然后停止遍历.

因为这步(不相同)会停止遍历, 所以前面每位都相同, 在保持前面不变的情况下, 可以直接忽略前面, 那么, 由于不相同, 必定有一个$1$, 有一个$0$.

因为前面都相等, 所以必定是大数这一位为$1$, 那就是这样的情况:

```
1xxxxx (大数)
0xxxxx (小数)
```

如果最终做运算的一个数可以取大数到小数之间的任何数字, 自然也包括`011111`, 而`011111|1xxxxx` 答案自然是`111111`, 后面无需再计算.

2. 如果两个数字的第$i$位相同, 答案这一位也相同.

由于遇到第一个不同的数字循环就会停止,  所以前面所有位都相同, 也就没有增减的余地, 这一位加1必定大于最大值, 减1必定小于最小值, 所以不变即可

# 代码

```cpp
#include <cstdio>
int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        long long a, b, ans = 0;
        scanf("%lld%lld", &a, &b);
        for (long long i = 60; i >= 0; i--) {
            if(!((1&(a>>i))^(1&(b>>i)))) ans^=(a&(1ll<<i));
            else{
                ans^=(1ll<<(i+1ll))-1ll;
                break;
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```
]]></description></item><item><title> P3295 萌萌哒 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/03/p3295.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 03 May 2020 15:10:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/03/p3295.html</guid><description><![CDATA[# 题目


一个长度为n的大数，用$S_1,S_2,S_3...S_n$表示，其中$S_i$表示数的第$i$位,$S_1$是数的最高位，告诉你一些限制条件，每个条
件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串$S_{l_1},S_{l_1+1},S+{l_1+2}...S_{r_1}$与$S_{l_2},S_{l_2+1},S_{l_2+2}...S_{r2}$完全相同。比如$n=6$时，某限制条件$l_1=1,r_1=3,l_2=4,r_2=6$，那么$123123$，$351351$均满足条件，但是$12012$，$131141$不满足条件，前者数的长度不为6，后者第二位与第五位不同。问满足以上所有条件的数有多少个。

# 输入格式

第一行两个数$n$和$m$，分别表示大数的长度，以及限制条件的个数。接下来$m$行，对于第$i$行,有4个数$l_{i_1},r_{i_1},l_{i_2},r_{i_2}$，分别表示该限制条件对应的两个区间。

$1≤n≤10^5,1≤m≤10^5,1≤l_{i_1},r_{i_1},l_{i_2},r_{i_2}≤n$并且保证$r_{i_1}-l_{i_1}=r_{i_2}-l_{i_2}$。

# 输出格式

一个数，表示满足所有条件且长度为n的大数的个数，答案可能很大，因此输出答案模 $10^9+7$的结果即可。

# 输入样例

```
4 2
1 2 3 4
3 3 3 3
```

# 输出样例

```
90
```

# 题解
![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503231026231-1638920927.png)



这道题使用并查集和ST表

$f$是$ST$表数组, $f_{i,j}$表示$[i,i+2^j-1]$

一个条件可以拆成$log$份，然后再合并。

若$f_{s,t}$和$f_{i,j}$在同一集合，则$f_{s,t-1}$与$f_{i,j-1}$以及$f_{s+2^{t-1}-1,t-1}$和$f_{i+2^{j-1}-1,j-1}$都在同一集合。

为了满足条件，一层一层的做，把下一层的合并，编号大的合进编号小。

设$tot$为集合个数

答案就是$9*10^(tot-1)$

# 代码

```cpp
#include <cmath>
#include <cstdio>
using namespace std;
int n, m, fa[100005][18], ans;
int find(int x, int k) { return fa[x][k] == x ? x : fa[x][k] = find(fa[x][k], k); }
void join(int x, int y, int k) { if ((x = find(x, k)) != (y = find(y, k))) fa[x][k] = y; }
int main() {
    scanf("%d %d", &n, &m);
    int maxk = floor(log2(n));
    for (int i = 1; i <= n; ++i)
        for (int k = 0; k <= maxk; ++k) fa[i][k] = i;
    for (int i = 1, l1, r1, l2, r2; i <= m; ++i) {
        scanf("%d %d %d %d", &l1, &r1, &l2, &r2);
        for (int k = maxk; ~k; --k)
            if (l1 + (1 << k) - 1 <= r1)
                join(l1, l2, k), l1 += 1 << k, l2 += 1 << k;
    }
    for (int k = maxk; k; --k)
        for (int i = 1; i + (1 << k) - 1 <= n; ++i) {
            int pos = find(i, k);
            join(i, pos, k - 1);
            join(i + (1 << k - 1), pos + (1 << k - 1), k - 1);
        }
    for (int i = 1; i <= n; ++i)
        if (fa[i][0] == i) ans = !ans ? 9 : ans * 10ll % 1000000007;
    printf("%d\n", ans);
    return 0;
}
```
]]></description></item><item><title>BZOJ1854 连续攻击游戏 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/05/03/bzoj1854.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 03 May 2020 12:22:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/03/bzoj1854.html</guid><description><![CDATA[

# 题目

lxhgww最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有2个属性，这些属性的值用[1,10000]之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 游戏进行到最后，lxhgww遇到了终极boss，这个终极boss很奇怪，攻击他的装备所使用的属性值必须从1开始连续递增地攻击，才能对boss产生伤害。也就是说一开始的时候，lxhgww只能使用某个属性值为1的装备攻击boss，然后只能使用某个属性值为2的装备攻击boss，然后只能使用某个属性值为3的装备攻击boss……以此类推。 现在lxhgww想知道他最多能连续攻击boss多少次？

# 输入格式

输入的第一行是一个整数N，表示lxhgww拥有N种装备 接下来N行，是对这N种装备的描述，每行2个数字，表示第i种装备的2个属性值

# 输出格式

输出一行，包括1个数字，表示lxhgww最多能连续攻击的次数。

# 输入样例

```
3
1 2
3 2
4 5
```

# 输出样例

```
2
```

# 题解

BZOJ日常挂...

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503203929462-1766993294.png)



洛谷AC:

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503203936041-435507127.png)



先说操作:

把武器的两个属性当作节点, 如果父亲不相等, 用并查集合并起来, 数值大的节点做父节点, 数值小的标记, 如果数值相等, 标记父亲

从$1$开始, 扫描每个节点(无论是否出现过), 如果$i$没有被标记, 就输出$i-1$

对应样例的图:

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503202053765-222287302.png)



加粗边缘的节点是已标记的

从$1$扫描到$3$, 未标记, 输出$2$

为什么要输出$i-1$呢? 很简单

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503202120558-1788255309.png)


红线圈住的部分是每个武器

因为每个武器只能使用一个属性, 所以最开始$1-2$, 只标记了$1$, 而后来$2$之所以也被标记, 是因为又出现了一个属性里含$2$的武器, 对于这个新武器, 不使用值为$3$的属性, 使用值为$2$的属性是完全没问题的, 不需要考虑之前的武器使用了什么.

由于从小到大依次使用属性, 所以被标记的是小的

这个$4-5$有什么作用? 如果又出现一个$3-4$武器, 那么图就会变成这样:

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503202101826-357513752.png)

所以保存其它的属性是为了以后的可能存在的更优解

-------

但是, 题中还要求使用的属性必须每次递增1, 如果武器的属性不是相差$1$呢?

比如这样的图:

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503202127604-416612794.png)



输出为$1$, 是正确的, 原因就是从$1$遍历到$2$的时候, $2$虽然没有出现过, 但也要遍历, 也要检查是否被标记, 当然没有被标记, 所以直接输出$2-1=1$了, 遍历过程中还发现这条路断了($1-2-3$中缺失$2$), 就输出能走到的最大节点$1$

如果还有一个武器是$2-3$的话, 图就会变成这样:

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503202134447-1760573369.png)



输出显然是$2$

别忘了, 当武器的两个属性父亲相等的时候, 直接标记父节点, 假设又出现了一个$1-2$武器, $2$和$3$的父亲是$3$, 相等, 那么图变成这样:

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503202139982-1586878690.png)



$3$节点也被标记了, 输出是$3$, 这个怎么理解呢?

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503202145753-4178242.png)



原本$1-3$武器不再使用属性值$1$,转而使用$3$, 因为新加入的武器含属性值$1$, 可以代替它执行$1$的职责

同理, 这个也可以看作$2-3$武器不再使用属性值$2$,转而使用$3$, 因为新加入的武器含属性值$2$, 可以代替它执行$2$的职责:

![](https://img2020.cnblogs.com/blog/1975074/202005/1975074-20200503202151431-936604185.png)



# 代码

```cpp
#include <cstdio>
#include <iostream>
int n, fa[1000005],x,y,p,q;
bool vis[1000005];
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
bool join(int x, int y) {
    if (x < y) std::swap(x, y);
    vis[y] = 1, fa[y] = x;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n + 1; i++) fa[i] = i;
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &x, &y);
        if((p = find(x)) == (q = find(y))) vis[p] = 1;
        else join(p, q);
    }
    for (int i = 1; i <= n + 1; i++)
        if (!vis[i]) {
            printf("%d", i - 1);
            break;
        }
    return 0;
}
```
]]></description></item><item><title>使用Python编写的对拍程序</title><link>http://www.cnblogs.com/youxam/archive/2020/05/01/check-with-python.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 01 May 2020 14:12:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/05/01/check-with-python.html</guid><description><![CDATA[# 简介

支持数据生成程序模式, 只要有RE或者WA的数据点, 就会停止

支持数据文件模式, 使用通配符指定输入文件, 将会对拍所有文件

结束后将会打印统计信息

第一次在某目录执行,将会通过交互方式获取配置, 生成配置文件, 以后读取配置文件运行

支持Linux和Windows系统

# 代码

```python
#!/usr/bin/python3
import os
import json
import platform
import time
import glob
import shutil


def confirm(msg, helpi=''):
    while True:
        cmd = input("{} [yes]/no{} : ".format(msg, "/help" if helpi else ''))
        if cmd == "no":
            return False
        elif cmd == "help" and helpi:
            print(helpi)
        else:
            return True


def getinput(msg, helpi=''):
    while True:
        cmd = input("{} {} : ".format(msg, "<input>/help" if helpi else ''))
        if cmd == "help" and helpi:
            print()
            print(helpi)
            print()
        elif cmd:
            return cmd


settings = {}
if not os.path.isfile("checkx.json"):
    try:
        print("未找到checkx.json配置文件\n")
        settings['std'] = getinput(
            "标准程序源代码路径", "1. 不需要使用freopen\n2. 可以使用绝对路径或相对路径")
        settings['target'] = getinput(
            "测试程序源代码路径", "1. 不需要使用freopen\n2. 可以使用绝对路径或相对路径")
        settings['ifpro'] = confirm(
            "是否使用数据生成程序?", "若输入yes, 将会使用数据生成程序生成数据\n若输入no,  将会使用数据文件")
        if settings['ifpro']:
            settings['pro'] = getinput("数据生成程序路径", "源程序应该直接输出数据")
        else:
            settings['file'] = getinput(
                "数据文件路径", "1. 可以使用绝对路径或相对路径\n2. 支持通配符")
        with open("checkx.json", "w") as f:
            f.write(json.dumps(settings))
    except KeyboardInterrupt:
        exit(0)
else:
    with open("checkx.json", "r") as f:
        settings = json.loads(f.read())
print("正在编译标准程序...", end='')
os.system("g++ {} -DDEBUG -o {}.out".format(settings['std'], settings['std']))
print("编译完成\n正在编译测试程序...", end='')
os.system(
    "g++ {} -DDEBUG -o {}.out".format(settings['target'], settings['target']))
print("编译完成")
if "Windows" in platform.platform():
    diffcmd = "fc /w target.out std.out > diff.out"
else:
    diffcmd = "diff -ZE target.out std.out > diff.out"
count = 0
times = []
stdtimes = []
account = 0
if settings['ifpro']:
    try:
        while True:
            count += 1
            os.system(".{}{} > in.in".format(os.sep, settings['pro']))
            zerotime = time.time()
            os.system(".{}{} < in.in > std.out".format(os.sep, settings['std']+".out"))
            begin = time.time()
            stdtimes.append(begin-zerotime)
            if not os.system("{} < in.in > target.out".format(settings['target']+".out")):
                print()
                print("# {} Runtime Error".format(count))
                print("\n输入:\n")
                with open("in.in", "r") as f:
                    print(f.read())
                break
            end = time.time()
            times.append(end-begin)
            if os.system(diffcmd):
                print()
                print("Wrong Answer")
                print("\n输入:\n")
                with open("in.in", "r") as f:
                    print(f.read())
                print("\n标准程序输出:\n")
                with open("std.out", "r") as f:
                    print(f.read())
                print("\n测试程序输出:\n")
                with open("target.out", "r") as f:
                    print(f.read())
                print("\n差异比较:\n")
                with open("diff.out", "r") as f:
                    print(f.read())
                break
            else:
                account += 1
                print("\r# {} Accepted {}s".format(
                    count, round(end-begin, 2)), end='')
    except KeyboardInterrupt:
        pass
else:
    try:
        for i in glob.glob(settings['file']):
            count += 1
            zerotime = time.time()
            os.system(".{}{} < {} > std.out".format(os.sep, settings['std']+".out", i))
            begin = time.time()
            stdtimes.append(begin-zerotime)
            if not os.system(".{}{} < {} > target.out".format(os.sep, settings['target']+".out", i)):
                print("# {} Runtime Error".format(count))
                print("\n输入保存在文件 result{}.in\n".format(count))
                shutil.copy(i, "result{}.in".format(count))
                continue
            end = time.time()
            times.append(end-begin)
            if os.system(diffcmd):
                print("# {} Wrong Answer".format(count))
                print("\n输入保存在文件result{}.in\n".format(count))
                shutil.copy(i, "result{}.in".format(count))
                print("\n标准程序输出保存在文件 result{}.ans\n".format(count))
                shutil.copy("std.out", "result{}.out".format(count))
                print("\n测试程序输出保存在文件 result{}.out\n".format(count))
                shutil.copy("target.out", "result{}.ans".format(count))
                print("\n差异比较保存在文件 result{}.diff\n".format(count))
                shutil.copy("diff.out", "result{}.diff".format(count))
            else:
                account += 1
                print("# {} Accepted {}s".format(count, round(end-begin, 2)))
    except KeyboardInterrupt:
        pass
print("\n共测试 {} 个数据点".format(count))
if count:
    print("{} 个数据点正确".format(account))
    print("正确率 {} %".format(round(account/count*100, 2)))
    if count:
        print("标准程序在正确的数据点中:\n\t平均时间 {} s".format(round(sum(stdtimes)/count, 2)))
    print("\t最长时间 {} s".format(round(max(stdtimes), 2)))
    print("\t最短时间 {} s".format(round(min(stdtimes), 2)))
    if account:
        print("测试程序在正确的数据点中:\n\t平均时间 {} s".format(round(sum(times)/account, 2)))
        print("\t最长时间 {} s".format(round(max(times), 2)))
        print("\t最短时间 {} s".format(round(min(times), 2)))
os.remove("diff.out")
os.remove("std.out")
os.remove("target.out")
os.remove(settings['std']+".out")
os.remove(settings['target']+".out")
if settings['ifpro']:
    os.remove("in.in")
```
]]></description></item><item><title>CF796C Bank Hacking 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/29/cf796c.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 29 Apr 2020 15:22:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/29/cf796c.html</guid><description><![CDATA[[洛谷链接](https://www.luogu.com.cn/problem/CF796C)

# 题目


Although Inzane successfully found his beloved bone, Zane, his owner, has yet to return. To search for Zane, he would need a lot of money, of which he sadly has none. To deal with the problem, he has decided to hack the banks.

There are n banks, numbered from 1 to n. There are also n - 1 wires connecting the banks. All banks are initially online. Each bank also has its initial strength: bank i has initial strength a i.

Let us define some keywords before we proceed. Bank i and bank j are neighboring if and only if there exists a wire directly connecting them. Bank i and bank j are semi-neighboring if and only if there exists an online bank k such that bank i and bank k are neighboring and bank k and bank j are neighboring.

When a bank is hacked, it becomes offline (and no longer online), and other banks that are neighboring or semi-neighboring to it have their strengths increased by 1.

To start his plan, Inzane will choose a bank to hack first. Indeed, the strength of such bank must not exceed the strength of his computer. After this, he will repeatedly choose some bank to hack next until all the banks are hacked, but he can continue to hack bank x if and only if all these conditions are met:

1. Bank x is online. That is, bank x is not hacked yet.
2. Bank x is neighboring to some offline bank.
3. The strength of bank x is less than or equal to the strength of Inzane's computer.

Determine the minimum strength of the computer Inzane needs to hack all the banks.

给定一棵带点权树，选出一个最佳的根节点，使得根节点的点权不变，它的儿子点权加1，其余点点权加2，并使最大点权最小，输出这个最小的最大点权

# 输入格式

The first line contains one integer $n (1 ≤ n ≤ 3·10^5)$ — the total number of banks.

The second line contains $n$ integers $a_1, a_2, ..., a_n ( - 10^9 ≤ a i ≤ 10^9)$ — the strengths of the banks.

Each of the next n - 1 lines contains two integers $u_i$ and $v_i (1 ≤ u_i, v_i ≤ n, u_i ≠ v_i)$ — meaning that there is a wire directly connecting banks $u_i$ and $v_i$.

# 输出格式

Print one integer — the minimum strength of the computer Inzane needs to accomplish the goal.

It is guaranteed that the wires connect the banks in such a way that Inzane can somehow hack all the banks using a computer with appropriate strength.

# 题解

>给定一棵带点权树，选出一个最佳的根节点，使得根节点的点权不变，它的儿子点权加1，其余点点权加2，并使最大点权最小，输出这个最小的最大点权

这是洛谷上的翻译, 很简洁明了.

这道题直接遍历一遍树, 按照题意统计一下就好了.

输入的时候先求出点权的最大值和每个权值的个数, 然后遍历每一个节点, 每个节点遍历每一个子节点, 根据题目性质计算即可.

# 代码

```cpp

#include <bits/stdc++.h>
using namespace std;
struct Edge { int to, next; } edges[600010];
int n, tot, ans, maxv = -0x3f3f3f3f, flag, x, y, a[300010], head[300010];
map<int, int> m;
void add(int x,int y) { edges[++tot] = (Edge){y, head[x]},head[x] = tot; }
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]), m[a[i]]++, maxv = max(maxv, a[i]);
    ans = maxv + 2; 
    for (int i = 1; i < n; i++) scanf("%d%d", &x, &y), add(x,y), add(y,x);
    for (int i = 1; i <= n; i++) {
        flag = 0;
        for (int j = head[i]; j; j = edges[j].next) {
            m[a[edges[j].to]]--; 
            if (a[edges[j].to] == maxv) flag = 1;
        }
        if (!m[maxv]) ans = maxv + 1;
        if (maxv == a[i] && m[maxv] == 1) {
            if (m[maxv - 1] || flag) // 其它节点有ans-1的权值,-1+2=+1 或者 子节点中也有最大值,子节点+1后是答案 
                ans = maxv + 1;
            else {
                ans = maxv; // 根节点是最大值, 并且子树中没有更大的, 直接break
                break;
            }
        }
        for (int j = head[i]; j; j = edges[j].next) m[a[edges[j].to]]++;
    }
    printf("%d\n", ans);
    return 0;
}
```
]]></description></item><item><title>BZOJ2200 道路与航线 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/29/bzoj2200.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 29 Apr 2020 13:45:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/29/bzoj2200.html</guid><description><![CDATA[# 题目

Farmer John正在一个新的销售区域对他的牛奶销售方案进行调查。他想把牛奶送到T个城镇 $(1 <= T <= 25,000)$，编号为$1T$。这些城镇之间通过$R$条道路 $(1 <= R <= 50,000$，编号为$1$到$R$) 和$P$条航线 $(1 <= P <= 50,000$，编号为$1$到$P$) 连接。每条道路i或者航线$i$连接城镇$A_i (1 <= A_i <= T)$到B$_i (1 <= B_i <= T)$，花费为$C_i$。对于道路，$0 <= C_i <= 10,000$;然而航线的花费很神奇，花费$C_i$可能是负数$(-10,000 <= C_i <= 10,000)$。道路是双向的，可以从$A_i$到$B_i$，也可以从$B_i$到$A_i$，花费都是$C_i$。然而航线与之不同，只可以从$A_i$到$B_i$。事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策保证：如果有一条航线可以从$A_i$到$B_i$，那么保证不可能通过一些道路和航线从$B_i$回到$A_i$。由于FJ的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。他想找到从发送中心城镇$S(1 <= S <= T)$ 把奶牛送到每个城镇的最便宜的方案，或者知道这是不可能的。

# 输入格式

* 第$1$行：四个空格隔开的整数:$ T, R, P$, and $S$ 

* 第$2$到$R+1$行：三个空格隔开的整数（表示一条道路）：$A_i, B_i 和 C_i$

* 第$R+2$到$R+P+1$行：三个空格隔开的整数（表示一条航线）：$A_i, B_i$ 和 $C_i$

# 输出格式

* 第1到T行：从S到达城镇i的最小花费，如果不存在输出"NO PATH"。

# 输入样例

```
6 3 3 4
1 2 5
3 4 5
5 6 10
3 5 -100
4 6 -100
1 3 -10
```

## 样例输入解释

一共六个城镇。在1-2，3-4，5-6之间有道路，花费分别是5，5，10。同时有三条航线：3->5，4->6和1->3，花费分别是-100，-100，-10。FJ的中心城镇在城镇4。

# 输出样例

```

NO PATH
NO PATH
5
0
-95
-100
```

## 样例输出解释

FJ的奶牛从4号城镇开始，可以通过道路到达3号城镇。然后他们会通过航线达到5和6号城镇。
但是不可能到达1和2号城镇。

# 题解

因为有负权存在, 所以不能用 Dijkstra 算法, 而且这道题还故意卡掉了 SPFA, 所以必须用别的方法.

注意, 题目中有一个特性, 双向边都是负的, 单向边都是正的, 而且构不成环.

如果把图中的单向边删掉, 只留下双向边, 那么就剩下来一些连通块, 因为全是双向边, 所以只要存在边, 就是联通的.

然后用类似 Tarjan 的办法, 把强连通分量看作一个点, 然后再添加单向边后, 就是一个有向无环图(DAG), 然后使用拓扑排序处理整个图, 使用 Dijkstra 处理每个连通块.

首先只加入双向边, DFS 求每个连通块, 根据输入的特性, 输入完道路之后 DFS 即可.

然后对于每个连通块, 和拓扑排序一样, 统计入度, 将入度为0的连通块加入队列. 

不断从队列中取出一个连通块, 进行 Dijkstra 松弛, 入度减一, 如果为0, 加入队列.

那么怎么进行 Dijkstra 松弛呢?

最开始定义一个数组, $d_i$表示$S$到$i$的最短路, 最开始$d_S=0$,其它初始化为无穷大.

拿到一个连通块之后, 把所有的点都加入优先队列,

不断从优先队列中取出$d$最小的点, 扫描每条出边, 进行松弛操作, 如果扫描到的出边终点不在此连通块, 就把终点所属连通块加入拓扑排序队列.

拓扑排序队列为空后, $d$数组就是要求的答案.

# 代码

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int MAXT = 25006, MAXRP = 150006, INF = 0x3f3f3f3f;
struct edges { int next, value, to;} edges[MAXRP];
int T, R, P, S, A, B, C, head[MAXT], tot = 0, c[MAXT], deg[MAXT], d[MAXT], totc = 0;
bool v[MAXT];
queue<int> q;
priority_queue<pair<int, int> > Q;
inline void add(int x, int y, int v) {
    edges[++tot].to = y;
    edges[tot].value = v;
    edges[tot].next = head[x];
    head[x] = tot;
}
void dfs(int i) {
    for (int j = head[i]; j; j = edges[j].next)
        if (!c[edges[j].to]) c[edges[j].to] = totc, dfs(edges[j].to);
}
int main() {
    memset(d, 0x7f, sizeof(d));
    scanf("%d%d%d%d",&T,&R,&P,&S);
    for (int i = 1; i <= R; i++)
        scanf("%d %d %d", &A, &B, &C), add(A, B, C), add(B, A, C);
    for (int i = 1; i <= T; i++)
        if (!c[i]) c[i] = ++totc, dfs(i);
    for (int i = 1; i <= P; i++)
        scanf("%d %d %d", &A, &B, &C), add(A, B, C), ++deg[c[B]];
    q.push(c[S]);
    for (int i = 1; i <= totc; i++)
        if (!deg[i]) q.push(i);
    d[S] = 0;
    while (q.size()) {
        int i = q.front();
        q.pop();
        for (int j = 1; j <= T; j++)
            if (c[j] == i) Q.push(make_pair(-d[j], j));
        while (Q.size()) {
            int x = Q.top().second;
            Q.pop();
            if (v[x]) continue;
            v[x] = 1;
            for (int j = head[x]; j; j = edges[j].next) {
                int y = edges[j].to;
                if (d[x] + edges[j].value < d[y]) {
                    d[y] = d[x] + edges[j].value;
                    if (c[x] == c[y]) Q.push(make_pair(-d[y], y));
                }
                if (c[x] != c[y] && !--deg[c[y]]) q.push(c[y]);
            }
        }
    }
    for (int i = 1; i <= T; i++) (d[i] > INF) ? puts("NO PATH") : printf("%d\n", d[i]);
    return 0;
}
```]]></description></item><item><title>USACO07NOV Cow Relays G 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/27/usaco07nov-cow-relays-g.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Mon, 27 Apr 2020 15:13:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/27/usaco07nov-cow-relays-g.html</guid><description><![CDATA[# 题目

For their physical fitness program, $N (2 ≤ N ≤ 1,000,000)$ cows have decided to run a relay race using the $T (2 ≤ T ≤ 100)$ cow trails throughout the pasture.

Each trail connects two different intersections $(1 ≤ I1_i ≤ 1,000; 1 ≤ I2_i ≤ 1,000)$, each of which is the termination for at least two trails. The cows know the lengthi of each trail $(1 ≤ lengthi  ≤ 1,000)$, the two intersections the trail connects, and they know that no two intersections are directly connected by two different trails. The trails form a structure known mathematically as a graph.

To run the relay, the N cows position themselves at various intersections (some intersections might have more than one cow). They must position themselves properly so that they can hand off the baton cow-by-cow and end up at the proper finishing place.

Write a program to help position the cows. Find the shortest path that connects the starting intersection (S) and the ending intersection (E) and traverses exactly N cow trails.

给出一张无向连通图，求S到E经过k条边的最短路。

# 输入格式

* Line $1$: Four space-separated integers: N, T, S, and E

* 一行四个正整数 $N,T,S,E$ ，意义如题面所示。

* Lines $2..T+1$: Line $i+1$ describes trail i with three space-separated integers: $length_i$ , $I1_i$ , and $I2_i$


* 接下来 $T$ 行每行三个正整数 $w,u,v$，分别表示路径的长度，起点和终点。

# 输出格式

* Line 1: A single integer that is the shortest distance from intersection S to intersection E that traverses exactly N cow trails.

* 一行一个整数表示图中从 $S$ 到 $E$ 经过 $N 条边的最短路长度。

# 输入样例

```
2 6 6 4
11 4 6
4 4 8
8 4 9
6 6 8
2 6 9
3 8 9
```
# 输出样例

```
10
```

# 题解

[矩阵](https://oi-wiki.org/math/matrix/)我不熟,看了大佬的一个式子:

把经过$x$个点的最短路的邻接矩阵$X$和经过$y$个点的最短路的邻接矩阵$Y$合并的式子为:

$A_{i,j}=min(A_{i,j},X_{i,k}+Y_{k,j})$

把输入转成邻接矩阵后,这个邻接矩阵可以看作恰好经过一个点的最短路,然后转移$n-1$次就可以了

矩阵相乘时,需要使用[快速幂](https://oi-wiki.org/math/quick-pow/)优化

# 代码


```c++

#include <cstdio>
#include <cstring>
#define min(a, b) (a < b ? a : b)
int num[1000005], n, s, t, e, tol, x, y, z;
struct map {
    int data[500][500];
    map operator*(const map &other) const {
        map c;
        for (int k = 1; k <= tol; k++)
            for (int i = 1; i <= tol; i++)
                for (int j = 1; j <= tol; j++)
                    c.data[i][j] =
                        min(c.data[i][j], data[i][k] + other.data[k][j]);
        return c;
    }
    map() { memset(data, 0x3f3f3f3f, sizeof(data)); }
} dis, ans;
inline int input() { int t; scanf("%d", &t);  return t; }
int main() {
    n = input() - 1, t = input(), s = input(), e = input();
    for (int i = 1; i <= t; i++) {
        x=input();
        if(!num[y=input()])num[y] = ++tol;
        if(!num[z=input()])num[z] = ++tol;
        dis.data[num[y]][num[z]] = dis.data[num[z]][num[y]] = x;
    }
    ans = dis;
    while (n) (n & 1) && (ans = ans * dis, 0), dis = dis * dis, n >>= 1;
    printf("%d",ans.data[num[s]][num[e]]);
}
```
]]></description></item><item><title>Numerical Sequence (Hard vision) 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/27/numerical-sequence-hard-vision.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Mon, 27 Apr 2020 13:13:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/27/numerical-sequence-hard-vision.html</guid><description><![CDATA[The only difference between the easy and the hard versions is the maximum value of $k$.

You are given an infinite sequence of form "112123123412345…" which consist of blocks of all consecutive positive integers written one after another. The first block consists of all numbers from $1$ to $1$, the second one — from $1$ to $2$, the third one — from $1$ to $3$, …, the i-th block consists of all numbers from $1$ to $i$.

So the first $56$ elements of the sequence are "11212312341234512345612345671234567812345678912345678910". Elements of the sequence are numbered from one. For example, the $1$-st element of the sequence is $1$, the $3$-rd element of the sequence is $2$, the $20$-th element of the sequence is $5$, the $38$-th element is $2$, the 56-th element of the sequence is $0$.

Your task is to answer $q$ independent queries. In the i-th query you are given one integer ki. Calculate the digit at the position ki of the sequence.

有一个无限长的数字序列，其组成为1 1 2 1 2 3 1.......1 2 ... n...，即重复的1 ~ 1,1 ~ 2....1 ~ n，这个数列连起来成为一个串,每位数字算一个元素,求第k(k<=1e18)个元素是什么

# 输入格式

The first line of the input contains one integer $q(1≤q≤500)$ — the number of queries.

The i-th of the following q lines contains one integer $k_i (1≤k_i≤10^{18})$ — the description of the corresponding query.

# 输出格式

Print q lines. In the i-th line print one digit $x_i (0≤xi≤9)$ — the answer to the query i, i.e. xi should be equal to the element at the position ki of the sequence.

# 样例输入1

```
5
1
3
20
38
56
```

# 样例输出1

```
1
2
5
2
0
```
# 样例输入2

```
4
2132
506
999999999999999999
1000000000000000000
```
# 样例输出2

```
8
2
4
1
```

# 题解

首先把原数列变成这样:

```
1
12
123
1234
12345
123456
1234567
12345678
123456789
12345678910
1234567891011
123456789101112
12345678910111213
1234567891011121314
```

你会发现,这个形状抽象以下就是这样:

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200427211019722-796949181.png)

当然每一块实际上不是等高的,这个斜边斜率之所以会改变,是因为其最后一个数字位数不同,在第一块,每一行增加一位,第二组每一行增加2位...

我们只需要事先预处理出每块含数字的数量,然后拿到$k$以后,进行二分就能找到$k$在哪一块.

那么怎么预处理呢?

首先已知:

1. 第一块第一行是1个数字

2. 第一块每行增加$1$个,第二块每行增加$2$个,第三行每行增加$3$个,第$i$块每行增加$i$个,设为$d_i$

3. 第一块有$9$行,第二块有$90$行,第三块有$900$行,第$i$块有$9 \times 10^{i-1}$,设为$l_i$


那就可以用等差数列求和公式预处理

注意,每一块都有自己的通项公式,描述该块内第几行有多少数字

那么现在求每一块内数字数量的问题就变成了 已知首项和公差,求前$n$项和.

首项由前一块的通项公式得出,公差为$d_i$, 由$n=l_i$可以求出该块数字数量,保存下来.

找到在哪一块之后,$k$减去前面所有块的数字数量,然后二分找到哪一行,每一行的数量由该块通项公式得出.

找到在哪一行之后,进行和以上类似的操作

比如这一行是


```
1
12
123
1234
12345
123456
1234567
12345678
123456789
12345678910
1234567891011
123456789101112
```

是不是似曾相识?

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200427211019722-796949181.png)

又是这个图,还是分块,分成1位数,2位数,3位数若干块(若干公差不同的等差数列),找到$k$在哪一块,然后枚举即可.

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10;
long long a[15], b[15], c[15], T, n;
int main() {
    for (int i = 1; i <= N; i++) {
        long long x = i, l = 1, r = 0;
        while (x--) l *= 10, r = r * 10 + 9;
        l /= 10;
        a[i] = (r - l + 1) * i;
        b[i] = b[i - 1] + a[i];
        c[i] = c[i - 1] + (b[i - 1] + i + b[i]) * (r - l + 1) / 2;
    }
    scanf("%lld", &T);
    while (T--) {   
        scanf("%lld", &n);
        long long pos = lower_bound(c + 1, c + N + 1, n) - c, l = 1, r = 0,
                  x = pos, t;
        n -= c[pos - 1];
        t = b[pos - 1];
        while (x--) l *= 10, r = 10 * r + 9;
        l /= 10;
        long long L = l;
        while (l <= r) {
            int mid = (l + r) >> 1, cnt = mid - L + 1;
            if ((2 * t + pos + cnt * pos) * cnt / 2 >= n)
                r = mid - 1;
            else
                l = mid + 1;
        }
        long long cnt = l - L;
        n -= (2 * t + pos + cnt * pos) * cnt / 2;
        pos = lower_bound(b + 1, b + N + 1, n) - b;
        n -= b[pos - 1];
        long long ans = 1;
        for (long long i = 1; i < pos; i++) ans *= 10;
        t = (n - 1) / pos;
        n -= t * pos;
        ans += t;
        n = pos - n;
        while (n--) ans /= 10;
        printf("%lld\n", ans % 10);
    }
    return 0;
}
```]]></description></item><item><title>BZOJ3573 米特运输 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/25/bzoj3573.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sat, 25 Apr 2020 15:22:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/25/bzoj3573.html</guid><description><![CDATA[# 题目

米特是D星球上一种非常神秘的物质，蕴含着巨大的能量。在以米特为主要能源的D星上，这种米特能源的运输和储存一直是一个大问题。D星上有N个城市，我们将其顺序编号为1到N，1号城市为首都。这N个城市由N-1条单向高速通道连接起来，构成一棵以1号城市（首部）为根的树，高速通道的方向由树中的儿子指向父亲。树按深度分层：根结点深度为0，属于第1层；根结点的子节点深度为1，属于第2层；依此类推，深度为i的结点属于第i+l层。建好高速通道之后，D星人开始考虑如何具体地储存和传输米特资源。由于发展程度不同，每个城市储存米特的能力不尽相同，其中第i个城市建有一个容量为A[i]的米特储存器。这个米特储存器除了具有储存的功能，还具有自动收集米特的能力。如果到了晚上六点，有某个储存器处于未满的状态，它就会自动收集大气中蕴含的米特能源，在早上六点之前就能收集满；但是，只有在储存器完全空的状态下启动自动收集程序才是安全的，未满而又非空时启动可能有安全隐患。早上六点到七点间，根节点城市（1号城市）会将其储存器里的米特消耗殆尽。根节点不会自动搜集米特，它只接受子节点传输来的米特。早上七点，城市之间启动米特传输过程，传输过程逐层递进：先是第2层节点城市向第1层（根节点城市，即1号城市）传输，直到第1层的储存器满或第2层的储存器全为空；然后是第3层向第2层传输，直到对于第2层的每个节点，其储存器满或其予节点（位于第3层）的储存器全为空；依此类推，直到最后一层传输完成。传输过程一定会在晚上六点前完成。

由于技术原因，运输方案需要满足以下条件：

1. 不能让某个储存器到了晚上六点传输结束时还处于非空但又未满的状态，这个时候储存器仍然会启动自动收集
米特的程序，而给已经储存有米特的储存器启动收集程序可能导致危险，也就是说要让储存器到了晚上六点时要么
空要么满；

2. 关于首都——即1号城市的特殊情况，  每天早上六点到七点间1号城市中的米特储存器里的米特会自动被消耗
殆尽，即运输方案不需要考虑首都的米特怎么运走；

3. 除了1号城市，每个节点必须在其子节点城市向它运输米特之前将这座城市的米特储存器中原本存有的米特全部
运出去给父节点，不允许储存器中残存的米特与外来的米特发生混合；

4. 运向某一个城市的若干个来源的米特数量必须完全相同，不然，这些来源不同的米特按不同比例混合之后可能
发生危险。

现在D星人已经建立好高速通道，每个城市也有了一定储存容量的米特储存器。为了满足上面的限制条件，可能需要重建一些城市中的米特储存器。你可以，也只能，将某一座城市（包括首都）中原来存在的米特储存器摧毁，再新建一座任意容量的新的米特储存器，其容量可以是小数（在输入数据中，储存器原始容量是正整数，但重建后可以是小数），不能是负数或零，使得需要被重建的米特储存器的数目尽量少。

# 输入格式

第一行是一个正整数$N$，表示城市的数目。接下来$N$行，每行一个正整数，其中的第$i$行表示第$i$个城市原来存在的米特储存器的容量。再接下来是$N-i$行，每行两个正整数a，b表示城市b到城市a有一条高速通道$(a \ne b)$。$N<500000，A[j]<10^8$

# 输出格式

输出文件仅包含一行，一个整数，表示最少的被重建（即修改储存器容量）的米特储存器的数目。

# 输入样例

```
5
5
4
3
2
1
1 2
1 3
2 4
2 5
```

# 输出样例

```
3
```

# 样例解释

一个最优解是将$A[1]$改成8，$A[3]$改成4，$A[5]$改成2。
这样，2和3运给1的量相等，4和5运给2的量相等，且每天晚上六点的时候，1，2满，3，4，5空，满足所有限制条件。

# 题解

看题快把我累死了。。。

一句话题意：**用最少次数改变权值，使每个节点的的子节点权值相同，且权值为除叶节点以外的子节点权值和，权值可以为小数但大于0**。

只要一个点的权值确定，所有点的权值就确定：

假设某节点的权值确定，则其兄弟节点的权值必定与其相同；其父节点权值必定等于该节点和其兄弟节点权值之和；其子节点权值必定等于该节点权值除以子节点数量。

dfs求保持某个节点不变的情况下根节点的权值，此时只保证一个点不变。

假设$A$不变，根节点权值为$W_A$，$B$不变，根节点权值为$W_B$

如果存在$A,B$，使$W_A=W_B$，那么可以同时让$A$,$B$保持不变，此时保证两个点不变，需要改变权值的数量减少一次。

那么对根节点权值的可能性计数，出现最多的情况权值就是最优情况下的权值。

注意，通过取对数，可以使乘法运算变成加法运算。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 5;
double w[maxn];
int a[maxn], in[maxn], value[maxn], vis[maxn << 1], next[maxn << 1], head[maxn << 1], tot = 0,ans = 0, t = 1;
inline void add(int x, int y) { vis[++tot] = y, next[tot] = head[x], head[x] = tot; }
void dfs(int v) {
    value[v] = 1;
    for (int i = head[v]; i; i = next[i])
        if (!value[vis[i]]) w[vis[i]] = w[v] + log(in[v]), dfs(vis[i]);
}
inline int input() { int t; scanf("%d", &t); return t; }
int main() {
    int n = input();
    for (int i = 1; i <= n; i++) a[i] = input();
    for (int i = 2; i <= n; i++) {
        int x = input(), y = input();
        add(x, y), add(y, x);
        in[x]++, in[y]++, in[i]--;
    }
    w[1] = log(1), dfs(1);
    for (int i = 1; i <= n; i++) w[i] += log(a[i]);
    sort(w + 1, w + n + 1);
    for (int i = 2; i <= n; i++)
        if (w[i] - w[i - 1] < 1e-7)t++;
        else ans = max(ans, t), t = 1;
    printf("%d",n - max(ans, t));
    return 0;
}
```
]]></description></item><item><title>POJ 3977 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/25/poj3977.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sat, 25 Apr 2020 13:11:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/25/poj3977.html</guid><description><![CDATA[

# 题目

Given a list of N integers with absolute values no larger than $10^{15}$, find a non empty subset of these numbers which minimizes the absolute value of the sum of its elements. In case there are multiple subsets, choose the one with fewer elements.

# 输入格式

The input contains multiple data sets, the first line of each data set contains N <= 35, the number of elements, the next line contains N numbers no larger than 10 15 in absolute value and separated by a single space. The input is terminated with N = 0

# 输出格式

For each data set in the input print two integers, the minimum absolute sum and the number of elements in the optimal subset.

# 样例输入

```
1
10
3
20 100 -100
0
```

# 样例输出

```
10 1
0 2
```

# 题解

我自己想的话，除了暴力没有别的办法，看了题解，照着打了一遍代码，才能理解这个解法

具体思想就是，全都暴力会超时，所以分成两半枚举，左半部分枚举完保存，右半部分枚举后在左半部分二分查询。

这算优化暴力吗，dalao们的暴力也和我的暴力不一样。。。

这个代码使用了不少STL~~也是一个学习STL的机会~~

# 代码

```cpp
#include <algorithm>
#include <cstdio>
#include <map>
using namespace std;
#define abs(x) ((x) >= 0 ? (x) : -(x))
long long arr[40];
int main() {
    int n;
    while (scanf("%d", &n), n) {
        for (int i = 0; i < n; i++) scanf("%lld", &arr[i]);
        pair<long long, long long> ans(abs(arr[0]), 1);
        map<long long, long long> m;
        map<long long, long long>::iterator it;
        int nl = n >> 1, nr = n - (n >> 1);
        for (int i = 1; i < (1 << nl); i++) {
            long long sum = 0, cnt = 0;
            for (int j = 0; j < nl; j++) {
                if ((i >> j) & 1) sum += arr[j], cnt++;
            }
            long long sum1 = abs(sum);
            if (sum1 < ans.first || (sum1 == ans.first && cnt < ans.second)) ans = make_pair(sum1, cnt);
            if (m[sum]) m[sum] = min(m[sum], cnt);
            else m[sum] = cnt;
        }
        for (int i = 1; i < (1 << nr); i++) {
            long long sum = 0, cnt = 0;
            for (int j = 0; j < nr; j++)
                if ((i >> j) & 1) sum += arr[j + nl], cnt++;
            long long sum1 = abs(sum);
            if (sum1 < ans.first || (sum1 == ans.first && cnt < ans.second)) ans = make_pair(sum1, cnt);
            it = m.lower_bound(-sum);
            if (it != m.end()) {
                long long s = abs(it->first + sum), t = it->second + cnt;
                if (s < ans.first || (s == ans.first && t < ans.second))
                    ans = make_pair(s, t);
            }
            if (it != m.begin()) {
                it--;
                long long s = abs(it->first + sum), t = it->second + cnt;
                if (s < ans.first || (s == ans.first && t < ans.second))
                    ans = make_pair(s, t);
            }
        }
        printf("%lld %lld\n", ans.first, ans.second);
    }
    return 0;
}
```
]]></description></item><item><title>P2607[ZJOI2008] 骑士 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/23/p2607.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Thu, 23 Apr 2020 14:01:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/23/p2607.html</guid><description><![CDATA[

# 题目

Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。

最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。

骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。

战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。

为了描述战斗力，我们将骑士按照 $1$ 至 $n$ 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。

# 输入格式

第一行包含一个整数 $n$，描述骑士团的人数。

接下来 $n$ 行，每行两个整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。

# 输出格式

应输出一行，包含一个整数，表示你所选出的骑士军团的战斗力。

# 输入样例

```
3
10 2
20 3
30 1
```

# 输出样例

```
30
```

# 题解

把每个骑士连接起来,形成一个图,如果A恨B,A不能和B在一起,B自然也就无法和A在一起,即使B不恨A,所以建图的时候建双向边.

然后就是树形DP

定义$f[i][j]$,$f[i][0]$表示以点$i$为根的子树中,不选择根时的最大战斗力,$f[i][1]$表示以点$i$为根的子树中,选择根时的最大战斗力.

设$u$为树根,$v$为$u$的每个儿子,$a[i]$表示点$i$的战斗力

显然,

$f[u][1]=\Sigma f[v][0]+a[u]$

$f[u][0]=\Sigma f[v][1]$

但是,注意本题可能出现环,并且最多只能出现一个环

这时候随便从中间拆开,变成一条链,端点设为$r1,r2$,然后以$r1$为根进行一次树形DP,不选$r1$(因为$r,r2$不能同时选),得到的值是$f[r1][0]$;然后相同操作,对$r2$也进行一次,得到的值记为$f[r2][0]$,然后把每一次树形DP的值的和就是答案.

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000000 + 10;
int head[N], cnt = 1, size[N], r1, r2,p[N];
struct Edge { int to, next; } edges[2 * N];
bool vis[N], flag;
long long ans, f[N][2];
void add(int x, int y) {
    edges[++cnt].next = head[x];
    edges[cnt].to = y;
    head[x] = cnt;
}
void dfs(int x, int fa) {
    vis[x] = 1;
    size[++size[0]] = x;
    for (int i = head[x]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v == fa) continue;
        if (!vis[v]) dfs(v, x);
        else if (vis[v] && !flag) {
            flag = true;
            r1 = x, r2 = v;
        }
    }
}
void dfs2(int x, int fa) {
    f[x][0] = 0;
    f[x][1] = p[x];
    for (int i = head[x]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v && v != fa) {
            dfs2(v, x);
            f[x][1] += f[v][0];
            f[x][0] += max(f[v][0], f[v][1]);
        }
    }
}
void solve() {
    if (!flag) {
        int root = size[1];
        dfs2(root, -1);
        ans += max(f[root][0], f[root][1]);
    } else {
        long long maxv = -100;
        for (int i = head[r1]; i; i = edges[i].next) {
            if (edges[i].to == r2) {
                edges[i].to = 0;
                edges[i ^ 1].to = 0;
                break;
            }
        }
        dfs2(r1, -1);
        maxv = max(maxv, f[r1][0]);
        dfs2(r2, -1);
        maxv = max(maxv, f[r2][0]);
        ans += maxv;
    }
}
int n;
int main() {
    scanf("%d", &n);
    int x, y;
    for (int i = 1; i <= n; i++) scanf("%d%d", &p[i], &x), add(i, x), add(x, i);
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            size[0] = 0;
            flag = false;
            dfs(i, -1);
            solve();
        }
    }
    printf("%lld", ans);
    return 0;
}
```
]]></description></item><item><title>Codeforces 1215D Ticket Game 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/23/codeforces-1215d.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Thu, 23 Apr 2020 01:56:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/23/codeforces-1215d.html</guid><description><![CDATA[[Codeforces 1215D Ticket Game 原题](https://codeforces.com/problemset/problem/1215/D)

# 题目  

Monocarp and Bicarp live in Berland, where every bus ticket consists of n digits (n is an even number). During the evening walk Monocarp and Bicarp found a ticket where some of the digits have been erased. The number of digits that have been erased is even.

Monocarp and Bicarp have decided to play a game with this ticket. Monocarp hates happy tickets, while Bicarp collects them. A ticket is considered happy if the sum of the first n2 digits of this ticket is equal to the sum of the last n2 digits.

Monocarp and Bicarp take turns (and Monocarp performs the first of them). During each turn, the current player must replace any erased digit with any digit from 0 to 9. The game ends when there are no erased digits in the ticket.

If the ticket is happy after all erased digits are replaced with decimal digits, then Bicarp wins. Otherwise, Monocarp wins. You have to determine who will win if both players play optimally.

一张票有n位数，如果这张票的前一半数字的和等于后一半数字的和(n一定是偶数)，就称这张票为快乐票。有些数被擦除了，标记为’?’(’?‘的个数也是偶数)，现在Monocarp 和 Bicarp 进行一个游戏，两人轮流将’?'变换成0到9的任意一个数，Monocarp先手，如果最后票为快乐票则Bicarp赢，否则Monocarp赢。

# 输入格式

The first line contains one even integer $n (2≤n≤2⋅10^5)$ — the number of digits in the ticket.

The second line contains a string of n digits and "?" characters — the ticket which Monocarp and Bicarp have found. If the i-th character is "?", then the i-th digit is erased. Note that there may be leading zeroes. The number of "?" characters is even.

先输入数字长度

然后输入这个数字,可能包括问号

# 输出格式

If Monocarp wins, print "Monocarp" (without quotes). Otherwise print "Bicarp" (without quotes).

谁赢输出谁的名字

# 样例

## 输入1

```
4
0523
```
## 输出1

```
Bicarp
```

## 输入2

```
2
??
```

## 输出2

```
Bicarp
```

## 输入3

```
8
?054??0?
```

## 输出3

```
Bicarp
```

## 输入4

```
6
???00?
```

## 输出4

```
Monocarp
```

# 题解

三种情况

1. 如果最开始左半部分数字之和等于右半部分数字之和,左右问号数量相等Bicarp赢;数量不等Monocarp赢.

应该很好理解,Monocarp先手,无论Monocarp填什么,Bicarp的最优策略都是在另一边填一样的,这样可以一直保证左右数字之和相等,因为Bicarp最后一个填,所以Bicarp赢.

当然,如果数量不等,Bicarp自然赢不了.

--------

**当两边数字和不等,且Monocarp可以在数字和大的部分填数字时,他一定会填9以拉开差距,那么Bicarp如果能在另半部分填,一定也会填9.**

**这就是两部分的问号不断抵消的情况,抵消到只有一边有问号为止,这时候就可以继续思考了,下面所有情况都是假定只有一边有问号**

2. 如果左半部分数字之和大于右半部分数字之和

若只有左边有问号,无论Bicarp如何决策也无法使左半部分减少,右半部分又无法增加,那么Monocarp赢

若只有右边有问号,那么Monocarp一定会填0拉开差距,而Bicarp一定会填9,那么看一下Bicarp能填的数量即可,若能填$n$个问号,$n \times 9$与左右之差相等,Bicarp赢,反之Monocarp赢.

注意写代码时,"只有左边有问号"的情况可以和"只有右边有问号"的情况合并,因为这时候看作右边的问号数量为负数即可,为负数肯定无法与正数的数量差相等,Monocarp赢一定会赢.


3. 如果左半部分数字之和小于右半部分数字之和

可以看作为第2种情况的镜像,同理可以解决

# 代码

```cpp
#include <bits/stdc++.h>
#define t(i) int(((double)(i) / (n)) + 0.5)
using namespace std;
char s[200005];
int main() {
    int n, mark[2] = {0, 0}, sum[2] = {0, 0};
    scanf("%d%s", &n, s);
    for (int i = 0; i < n; i++)
        if (s[i] == '?') mark[t(i)]++;
        else sum[t(i)] += s[i] - '0';
    puts((mark[0] == mark[1] && sum[0] == sum[1] ||
          sum[0] > sum[1] && sum[0] - sum[1] == (mark[1] - mark[0]) / 2 * 9 ||
          sum[1] > sum[0] && sum[1] - sum[0] == (mark[0] - mark[1]) / 2 * 9) ? "Bicarp" : "Monocarp");
    return 0;
}
```
]]></description></item><item><title>HDU 4352 XHXJ's LIS HDU 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/22/hdu4352.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Tue, 21 Apr 2020 16:02:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/22/hdu4352.html</guid><description><![CDATA[# 题目

\#define xhxj (Xin Hang senior sister(学姐))
If you do not know xhxj, then carefully reading the entire description is very important.
As the strongest fighting force in UESTC, xhxj grew up in Jintang, a border town of Chengdu.
Like many god cattles, xhxj has a legendary life:
2010.04, had not yet begun to learn the algorithm, xhxj won the second prize in the university contest. And in this fall, xhxj got one gold medal and one silver medal of regional contest. In the next year's summer, xhxj was invited to Beijing to attend the astar onsite. A few months later, xhxj got two gold medals and was also qualified for world's final. However, xhxj was defeated by zhymaoiing in the competition that determined who would go to the world's final(there is only one team for every university to send to the world's final) .Now, xhxj is much more stronger than ever，and she will go to the dreaming country to compete in TCO final.
As you see, xhxj always keeps a short hair(reasons unknown), so she looks like a boy( I will not tell you she is actually a lovely girl), wearing yellow T-shirt. When she is not talking, her round face feels very lovely, attracting others to touch her face gently。Unlike God Luo's, another UESTC god cattle who has cool and noble charm, xhxj is quite approachable, lively, clever. On the other hand,xhxj is very sensitive to the beautiful properties, "this problem has a very good properties"，she always said that after ACing a very hard problem. She often helps in finding solutions, even though she is not good at the problems of that type.
Xhxj loves many games such as，Dota, ocg, mahjong, Starcraft 2, Diablo 3.etc，if you can beat her in any game above, you will get her admire and become a god cattle. She is very concerned with her younger schoolfellows, if she saw someone on a DOTA platform, she would say: "Why do not you go to improve your programming skill". When she receives sincere compliments from others, she would say modestly: "Please don’t flatter at me.(Please don't black)."As she will graduate after no more than one year, xhxj also wants to fall in love. However, the man in her dreams has not yet appeared, so she now prefers girls.
Another hobby of xhxj is yy(speculation) some magical problems to discover the special properties. For example, when she see a number, she would think whether the digits of a number are strictly increasing. If you consider the number as a string and can get a longest strictly increasing subsequence the length of which is equal to k, the power of this number is k.. It is very simple to determine a single number’s power, but is it also easy to solve this problem with the numbers within an interval? xhxj has a little tired，she want a god cattle to help her solve this problem,the problem is: Determine how many numbers have the power value k in $[L，R]$ in O(1)time.
For the first one to solve this problem，xhxj will upgrade 20 favorability rate。

给定L到R区间，和一个数字$K$

对$[L,R]$每一个数字，把数字当作序列，数字的每一位当作序列的元素，求$LIS$长度为$k$的数字的个数

# 输入格式

First a integer $T(T<=10000)$,then $T$ lines follow, every line has three positive integer $L,R,K(0<L \le R < 2 ^ {63}-1,1 \le K \le 10)$.

# 输出格式

For each query, print "Case #t: ans" in a line, in which $t$ is the number of the test case starting from 1 and ans is the answer.

# 题解

依旧是我很不熟的数位dp，直接套板子，求$LIS$用$O(n log n)$的复杂度的方法，$[L,R]$区间差分。

重点说一下状压下的$LIS$，由于最长长度为10，所以可以不用二分，这样求$LIS$的复杂度是$O(n)$。

注意这个存储方式不同，状态从右往左编号，依次0-9。如果在状态中为1，说明它出现过，因为是$LIS$，所以顺序肯定是递增的，所以只需要存下来出现过什么数字，就相当于原来的dp数组。

当更新状态时，从新的pos开始，往后面遍历，遇到的第一个1就是比自己大或者等于的，将其置0，新pos位置 置1，这就是一个更新操作。

举个例子:

原状态:

```
0001000010
```

表示长度为1的上升子序列结尾元素是1，长度为2的上升子序列结尾元素是6, LIS长度为2

那么现在发现，有一个长度为2的上升子序列结尾元素为4，需要更新一下

从第4位(实际上是第5位)开始
```
00010[0]0010
0001[0]00010
000[1]000010
```
找到一个1，把它置零
```
000[0]000010
```
然后把 第4位 置1(更新)
```
00000[1]0010
```
现在更新后的状态就是
```
0000010010
```
表示长度为1的上升子序列结尾元素是1，长度为2的上升子序列结尾元素是4, LIS长度为2

LIS长度是通过1的个数算出来的，可以用lowbit计算，我使用的是内置函数`__builtin_popcountll`，应该也是lowbit实现的

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int k, number[20];
ll dp[20][1 << 10][11];

ll newStatus(ll status, ll num) {
    for (int i = num; i <= 9; i++)
        if (status & (1 << i)) return (status ^ (1 << i)) | (1 << num);
    return status | (1 << num);
}
ll dfs(int position, ll status, bool lead, bool limit) {
    if (position == 0) return __builtin_popcountll(status) == k;
    if (!limit && dp[position][status][k] != -1) return dp[position][status][k];
    int up = limit ? number[position] : 9;
    ll ans = 0;
    for (int i = 0; i <= up; i++)
        ans += dfs(position - 1, (lead && i == 0) ? 0 : newStatus(status, i), lead && i == 0, limit && i == up);
    if (!limit) dp[position][status][k] = ans;
    return ans;
}
ll solve(ll x) {
    int length = 0;
    while (x) number[++length] = x % 10, x /= 10;
    return dfs(length, 0ll, true, true);
}

int main() {
    int t;
    scanf("%d", &t);
    memset(dp, -1, sizeof(dp));
    for (int Case = 1; Case <= t; Case++) {
        long long l, r;
        scanf("%lld%lld%d", &l, &r, &k);
        printf("Case #%d: %lld\n", Case, solve(r) - solve(l - 1));
    }
}
```
]]></description></item><item><title>CF833A The Meaningless Game 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/21/cf833a.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Tue, 21 Apr 2020 14:46:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/21/cf833a.html</guid><description><![CDATA[# 题目

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200421224535305-59288825.png)

Slastyona and her loyal dog Pushok are playing a meaningless game that is indeed very interesting.

The game consists of multiple rounds. Its rules are very simple: in each round, a natural number kk is chosen. Then, the one who says (or barks) it faster than the other wins the round. After that, the winner's score is multiplied by $k^{2}$, and the loser's score is multiplied by kk . In the beginning of the game, both Slastyona and Pushok have scores equal to one.

Unfortunately, Slastyona had lost her notepad where the history of all nn games was recorded. She managed to recall the final results for each games, though, but all of her memories of them are vague. Help Slastyona verify their correctness, or, to put it another way, for each given pair of scores determine whether it was possible for a game to finish with such result or not.

Slastyona和她的忠实狗狗普什克正在玩一个毫无意义但是很有趣的游戏。游戏包括多个回合。

它的规则非常简单：先选择一个自然数$k$。然后，谁说（或吠）的比另一个快就会赢得一局。胜利者的得分在那之后会乘以k的平方，而输了的人的得分就只能乘以k。比赛开始时，Slastyona和PurSok都有一个初始分数。不幸的是，Slastyona丢失了记事本，那里记录了他们玩过的N个游戏的历史。她设法回忆了每一场比赛的最终结果，但是记忆都很模糊。帮助Slastyona验证它们的正确性，或者，换句话说，对于每一对给定的分数，确定游戏是否能够完成这样的结果。

# 输入格式

In the first string, the number of games $n (1 ≤ n ≤ 350000)$ is given.

Each game is represented by a pair of scores a, $b (1 ≤ a, b ≤ 109)$ – the results of Slastyona and Pushok, correspondingly.

# 输出格式

For each pair of scores, answer "Yes" if it's possible for a game to finish with given score, and "No" otherwise.

You can output each letter in arbitrary case (upper or lower).

#　样例输入

```cpp
6
2 4
75 45
8 8
16 16
247 994
1000000000 1000000
```

# 样例输出

```
Yes
Yes
Yes
No
No
Yes
```

# 题解

设$a$和$b$是两个人比赛的得分，对于$a$和$b$来说，每轮游戏不是$a=a \cdot k,b=b \cdot k^2$，就是$a=a \cdot k^2,b=b \cdot k$,显然每轮游戏，$a \cdot b$的总和都会被乘$k^3$，那么对 最后得分 开三次方后是整数，说明可能存在这种情况。

但是注意，这个条件并不充足。

还有一个条件，就是开立方的结果是$a$和$b$的因数

$\because ab=k^{3n}$

$\therefore \sqrt[3]{ab} = \sqrt[3]{k^{3n}} = k^n $

设进行了$p$次游戏，$a$或$b$最少乘了$p$次$k$，则$k^n$(开立方结果)一定是$a$和$b$的因数

反过来也成立，当$\sqrt[3]{ab}=k^n$是整数 且 $k^n$是$a$和$b$的因数 时，得分是合法的

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        long long a, b;
        scanf("%lld%lld", &a, &b);
        long long m = pow(a * b, (1.0 / 3)) + 0.5;
        puts((m * m * m != a * b || a % m || b % m) ? "No" : "Yes");
    }
    return 0;
}

```
]]></description></item><item><title>CF55D Beautiful numbers 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/17/cf55d-beautiful-numbers.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 17 Apr 2020 04:31:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/17/cf55d-beautiful-numbers.html</guid><description><![CDATA[# 题目
Volodya is an odd boy and his taste is strange as well. It seems to him that a positive integer number is beautiful if and only if it is divisible by each of its nonzero digits. We will not argue with this and just count the quantity of beautiful numbers in given ranges.

Volodya是个奇怪的男孩，他的品味也很奇怪。 在他看来，当且仅当正整数可以被其每个非零数字整除时，它才是Beautiful的。 我们不会对此争论，而只计算给定范围内的 Beautiful number的数量。

# 输入格式

The first line of the input contains the number of cases $ t (1 \le t \le 10)$. Each of the next t lines contains two natural numbers $l_i$ and $r_i (1 \le li \le ri \le 9 \times 10^{18})$.

Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).

输入的第一行包含数据组数$t(1 \le t \le 10)$, 接下来的t行中的每行包含两个自然数$l_i $和$r_i(1 \le l_i \le r_i \le 9 \times 10 ^ {18})$.

请不要使用％lld在C ++中读取或写入64位整数。 建议使用cin（也可以使用％l64d）.

# 输出格式

Output should contain tt numbers — answers to the queries, one number per line — quantities of beautiful numbers in given intervals (from $l_{i}$ to $r_i$, inclusively).

t行，每行输出从$l_{i}$ 到 $r_i$的Beautiful number的数量

# 题解

这道题是数位DP<span class="heimu">我好像没学过啊</span>,而且还是黑题...最开始真是一点思路都没有,后来看了dalao们的题解才能写出来.

这道题让求一段范围内的,比较容易想到的就是差分,求出$1$到$r$的数量,再求出$1$到$l-1$的数量,相减即可.

注意每位数都是$1-9$,他们的最小公倍数是$2520$,所以如果一个数可以整除$2520$,就一定可以整除$1-9$.

设$dp[i][j][k]$,$i$表示还剩下多少位数要规划,这前$i$位数模$2520$的余数是$j$,这前$i$位数的最小公倍数是$k$.

如果最后的数能整除$k$，那么它一定能整除它各位数字的最小公倍数

有可能出现的$k$都是$2520$的因数,所以将$j$取模$2520$,若所得的结果整除$k$，那么原来的数也一定整除$k$.

所以就可以得到状态转移方程

$dp[i][j][k]= \Sigma_{x=1}^{x_{max}} \ \ \ \  dp[i−1][(j \times 10+x) \% 2520][lcm(k,x)]$


$lcm(a,b)$表示$a$和$b$的最小公倍数

但是如果开这么大的数组,会MLE,所以需要继续优化,注意第三维是$lcm(k,x)$,是从$1-9$之间取数字做$lcm$运算,得到的结果数量远远少于$2520$,所以与处理一下做一个离散化即可.

希望有一天能自己独立写出黑题.

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int number[20], mp[2521], cnt;
long long dp[20][2521][50],l, r, t;
int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
long long dfs(int length, int pre, int mod, bool limit ,long long ans = 0) {
    if (!length) return pre % mod == 0;
    if (!limit && dp[length][pre][mp[mod]] != -1) return dp[length][pre][mp[mod]];
    int ed = limit ? number[length] : 9;
    for (int i = 0; i <= ed; i++)   
        ans += dfs(length - 1, (pre * 10 + i) % 2520, i == 0 ? mod : mod * i / gcd(mod, i), limit && i == ed);
    if (!limit) dp[length][pre][mp[mod]] = ans;
    return ans;
}
long long solve(long long n, int length = 0) {
    while (n) number[++length] = n % 10, n /= 10;
    return dfs(length, 0, 1, 1);
}
int main() {
    memset(dp, -1, sizeof(dp));
    for (int i = 1; i <= 2520; i++)
        if (!(2520 % i)) mp[i] = ++cnt;
    cin >> t;
    while (t--) {
        cin >> l >> r;
        cout << solve(r) - solve(l - 1) << endl;
    }
    return 0;
}
```

<span class="heimu">代码如有雷同,不是巧合</span>
]]></description></item><item><title>NOIP2016 蚯蚓 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/17/noip2016-earthworm.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Thu, 16 Apr 2020 16:04:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/17/noip2016-earthworm.html</guid><description><![CDATA[# 题目

本题中，我们将用符号 $\lfloor c \rfloor$ 表示对 $c$ 向下取整，例如：$\lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3$。

蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。

蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i(i=1,2,\dots,n)$，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。

每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0 < p < 1$的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\lfloor px \rfloor$ 和 $x - \lfloor px \rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。

蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来……（$m$ 为非负整数）

蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：

$m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）；
$m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。
蛐蛐国王当然知道怎么做啦！但是他想考考你……

# 输入格式

输入格式
第一行包含六个整数 $n,m,q,u,v,tn,m,q,u,v,t$，其中：$n,m,q$ 的意义见【问题描述】；$u,v,t$ 均为正整数；你需要自己计算 $p=\frac u v$（保证 $0 < u < v$）；$t$ 是输出参数，其含义将会在【输出格式】中解释。

第二行包含 $n$ 个非负整数，为 $a_1, a_2, \dots$ ，即初始时 $n$ 只蚯蚓的长度。

同一行中相邻的两个数之间，恰好用一个空格隔开。

保证$ 1 \leq n \le 10^5,0 \leq m \leq 7 \times 10 ^ 6,0 < u < v < 10^9，0<=q<=200,1< t <71,0< a_i <10^8$

# 输出格式

第一行输出 $\left \lfloor \frac{m}{t} \right \rfloor$个整数，按时间顺序，依次输出第 $t$ 秒，第 $2t$ 秒，第 $3t$ 秒,……被切断蚯蚓（在被切断前）的长度。

第二行输出 $\left \lfloor \frac{n+m}{t} \right \rfloor$个整数，输出 $m$ 秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 $t$，第 $2t$，第 $3t$，……的长度。

同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。

请阅读样例来更好地理解这个格式。

# 输入输出样例

## 输入1
```cpp
3 7 1 1 3 1
3 3 2
```
## 输出1
```cpp
3 4 4 4 5 5 6
6 6 6 5 5 4 4 3 2 2
```
## 输入2
```cpp
3 7 1 1 3 2
3 3 2
```
## 输出2
```cpp
4 4 5
6 5 4 3 2
```
## 输入3
```cpp
3 7 1 1 3 9
3 3 2
```
## 输出3
```cpp
//空行
2
```

# 题解

假设其它蚯蚓不会边长,这道题直接模拟的话,就是要做到查询最大值,删除最大值,插入新的值三种操作,使用优先队列即可实现.

但蚯蚓会变长,不过也只是需要改一下,因为除了最大值会被拆成两个数,其他数都会增加$q$,设最大值为$x$,那么只需要认为$x$被拆成$\lfloor px \rfloor - q$和$x - \lfloor px \rfloor - q$ ,然后把所有数都加上$q$,这样是等价的,.

注意这里"把所有数都加上$q$"是延迟操作,不是当时就加上,而是把每次操作加上的$q$加起来,设为$delta$,因为所有数都是同时加上$q$,所以只需要一个 $delta$,每次加$q$,$delta$就自增$q$,然后在读取集合中的数字时,先加上$delta$再使用即可.

所以对于每一秒:

1. 取出集合中的最大值$x$,令$x=x+delta$
2. 把$\lfloor px \rfloor - q-delta$和$x - \lfloor px \rfloor - q-delta$插入集合
3. 令 $delta=delta+q$

这三步重复$m$次,集合中的数就是最终的数字,但是问题来了,$0 \leq m \leq 7 \times 10 ^ 6$,这个复杂度太高,还是会t,所以得优化.

题中给了$0 < p < 1$,设 $x_1,x_2$ 为非负整数

当$x_1 \ge x_2$

$\because \lfloor px_1 + q \rfloor \ge \lfloor px_2 + pq \rfloor$

$\therefore \lfloor px_1  \rfloor + q \ge \lfloor p(x_2 + q) \rfloor$

$\because x_1 - x_2 \ge p(x_1-x_2)$

$\therefore x_1-px_1 \ge x_2-px_2 \ge x_2 - p(x_2+q)$

$\therefore \lfloor x_1 - px_1 \rfloor +q\ge \lfloor x_2-p(x_2+q)\rfloor+q$

$\therefore x_1-\lfloor px_1\rfloor +q \ge x_2+q-\lfloor p(x_2)+q \rfloor$

得到这个有什么用呢?如果$x_1$在$x_2$之前被取出集合,在一秒后,$x_1$分成的两个数$\lfloor px_1  \rfloor + q$和$x-\lfloor px_1  \rfloor + q$ **分别** 不小于$x_2$分成的两个数$\lfloor p(x_2 + q) \rfloor$和$x_2+q-\lfloor p(x_2)+q \rfloor$,所以新产生的两个数也**分别**单调递减.

由于**分别**单调递减,所以只需要分两个队列保存即可,比如分成的前半部分一个队列,后半部分一个队列,再和原本的队列的首项比较最大值,最大的取出来分.

到这里,基本思路就明确了,但是当我高兴地写完,往[洛谷](https://www.luogu.com.cn/problem/P2827)上面交也过了,当我往Vjudge上交的时候,却TLE了

这是我当时的代码:

```cpp
#include <cstdio>
#include <queue>
using namespace std;
long long INF = 0x3f3f3f3f3f3f3f3f;
int n, m, q, u, v, t, delta = 0, w;
priority_queue<long long> pq;
queue<long long> q1, q2;
inline long long input() { long long t; scanf("%lld", &t); return t; }
int main() {
    scanf("%d%d%d%d%d%d", &n, &m, &q, &u, &v, &t);
    for (int i = 1; i <= n; i++) pq.push(input());
    for (int i = 1; i <= m; i++) {
        long long maxx = -INF;
        if (pq.size() && maxx < pq.top()) maxx = pq.top(), w = 0;
        if (q1.size() && maxx < q1.front()) maxx = q1.front(), w = 1;
        if (q2.size() && maxx < q2.front()) maxx = q2.front(), w = 2;
        w == 1 ? q1.pop() : w == 2 ? q2.pop() : pq.pop();
        maxx += delta;
        q1.push(maxx * u / v - delta - q), q2.push(maxx - maxx * u / v - delta - q);
        delta += q;
        if (i % t == 0) printf("%lld ", maxx);
    }
    printf("\n");
    for (int i = 1; i <= n + m; i++) {
        long long maxx = -INF;
        if (pq.size() && maxx < pq.top()) maxx = pq.top(), w = 0;
        if (q1.size() && maxx < q1.front()) maxx = q1.front(), w = 1;
        if (q2.size() && maxx < q2.front()) maxx = q2.front(), w = 2;
        w == 1 ? q1.pop() : w == 2 ? q2.pop() : pq.pop();
        if (i % t == 0) printf("%lld ", maxx + delta);
    }
    return 0;
}
```

这就比较神奇,我看了别人的代码,发现不少人的输入用数组输入然后排序,虽然理论上和我这个复杂度一样,但众所周知,STL自带大常数,所以我把优先队列删了,改成了这样:

```cpp
#include <algorithm>
#include <cstdio>
#include <queue>
using namespace std;
long long INF = 0x3f3f3f3f3f3f3f3f;
int n, m, q, u, v, t, delta = 0, w, a[100005], ai = 1;
queue<long long> q1, q2;
bool cmp(int a, int b) { return a > b; }
int main() {
    scanf("%d%d%d%d%d%d", &n, &m, &q, &u, &v, &t);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    sort(a + 1, a + n + 1, cmp);
    for (int i = 1; i <= m; i++) {
        long long maxx = -INF;
        if (ai <= n && maxx < a[ai]) maxx = a[ai], w = 0;
        if (q1.size() && maxx < q1.front()) maxx = q1.front(), w = 1;
        if (q2.size() && maxx < q2.front()) maxx = q2.front(), w = 2;
        if(w == 1) q1.pop();
        else if (w == 2) q2.pop();
        else ai++;
        maxx += delta;
        q1.push(maxx * u / v - delta - q), q2.push(maxx - maxx * u / v - delta - q);
        delta += q;
        if (i % t == 0) printf("%lld ", maxx);
    }
    printf("\n");
    for (int i = 1; i <= n + m; i++) {
        long long maxx = -INF;
        if (ai <= n && maxx < a[ai]) maxx = a[ai], w = 0;
        if (q1.size() && maxx < q1.front()) maxx = q1.front(), w = 1;
        if (q2.size() && maxx < q2.front()) maxx = q2.front(), w = 2;
        if(w == 1) q1.pop();
        else if (w == 2) q2.pop();
        else ai++;
        if (i % t == 0) printf("%lld ", maxx + delta);
    }
    return 0;
}
```

可是悲伤的事情来了,居然还是TLE...,这次是同学提醒我,队列用不上`long long`,只需要计算的时候用`long long`就可以,因为**使用long long的queue比使用int的queue要慢**,这点看似不起眼的优化却让我AC了,这是我第一次被STL坑的这么惨,以后长教训了,能不用STL就不用

# 代码

```cpp

#include <algorithm>
#include <cstdio>
#include <queue>
using namespace std;
long long INF = 0x3f3f3f3f3f3f3f3f;
int n, m, q, u, v, t, delta = 0, w, a[100005], ai = 1;
queue<int> q1, q2;
bool cmp(int a, int b) { return a > b; }
int main() {
    scanf("%d%d%d%d%d%d", &n, &m, &q, &u, &v, &t);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    sort(a + 1, a + n + 1, cmp);
    for (int i = 1; i <= m; i++) {
        long long maxx = -INF;
        if (ai <= n && maxx < a[ai]) maxx = a[ai], w = 0;
        if (q1.size() && maxx < q1.front()) maxx = (long long)q1.front(), w = 1;
        if (q2.size() && maxx < q2.front()) maxx = (long long)q2.front(), w = 2;
        if(w == 1) q1.pop();
        else if (w == 2) q2.pop();
        else ai++;
        maxx += delta;
        q1.push(maxx * u / v - delta - q), q2.push(maxx - maxx * u / v - delta - q);
        delta += q;
        if (i % t == 0) printf("%lld ", maxx);
    }
    printf("\n");
    for (int i = 1; i <= n + m; i++) {
        long long maxx = -INF;
        if (ai <= n && maxx < a[ai]) maxx = a[ai], w = 0;
        if (q1.size() && maxx < q1.front()) maxx = (long long)q1.front(), w = 1;
        if (q2.size() && maxx < q2.front()) maxx = (long long)q2.front(), w = 2;
        if(w == 1) q1.pop();
        else if (w == 2) q2.pop();
        else ai++;
        if (i % t == 0) printf("%lld ", maxx + delta);
    }
    return 0;
}
```]]></description></item><item><title>BZOJ 1294 围豆豆 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/14/bzoj-1294.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Tue, 14 Apr 2020 14:23:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/14/bzoj-1294.html</guid><description><![CDATA[# 题目

是不是平时在手机里玩吃豆豆游戏玩腻了呢？最近MOKIA手机上推出了一种新的围豆豆游戏，大家一起来试一试吧。

游戏的规则非常简单，在一个N×M的矩阵方格内分布着D颗豆子，每颗豆有不同的分值Vi。游戏者可以选择任意一个方格作为起始格，每次移动可以随意的走到相邻的四个格子，直到最终又回到起始格。最终游戏者的得分为所有被路径围住的豆豆的分值总和减去游戏者移动的步数。矩阵中某些格子内设有障碍物，任何时刻游戏者不能进入包含障碍物或豆子的格子。游戏者可能的最低得分为0，即什么都不做。

注意路径包围的概念，即某一颗豆在路径所形成的多边形（可能是含自交的复杂多边形）的内部。下面有两个例子：

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200414222349590-1001741746.png)





第一个例子中，豆在路径围成的矩形内部，所以豆被围住了。第二个例子中，虽然路径经过了豆的周围的8个格子，但是路径形成的多边形内部并不包含豆，所以没有围住豆子。

布布最近迷上了这款游戏，但是怎么玩都拿不了高分。聪明的你决定写一个程序来帮助他顺利通关。

# 输入格式

第一行两个整数$N$和$M$，为矩阵的边长。

第二行一个整数$D$，为豆子的总个数。

第三行包含$D$个整数$V_1$到$V_D$，分别为每颗豆子的分值。

接着$N$行有一个$N \times M$的字符矩阵来描述游戏矩阵状态，`0`表示空格，`#`表示障碍物。而数字`1`到`9`分别表示对应编号的豆子。

# 输出格式

仅包含一个整数，为最高可能获得的分值。

# 样例输入

```
3 8
3
30 -100 30
00000000
010203#0
00000000
```

# 样例输出

```
38
```

# 说明/提示

50%的数据满足$1 \le D \le 3$。

100%的数据满足$1 \le D \le 9,1 \le N, M \le 10，-10000 \le V_i \le 10000$。

# 题解

$N,M$的范围都很小,所以可以直接暴力广搜,但是保存状态不能直接用数组,处理起来会很麻烦,应该状态压缩.

我重点讲一下怎么判断一个点是否在多边形内:

先说结论,**从某点向外做射线，若该射线与多边形相交了奇数次，该点就在该多边形的内部，否则在外部**

下面证明

我们设想这个射线是从这个点出发的一条路径,在我们沿着这个路径走的过程中,可以得到以下结论:

由于射线无限长,而多边形有限,所以射线最后一次与多边形相交一定是从多边形内部交到外部,由此可得,倒数第二次相交(如果有的话)一定是从外部交到内部.

所以每交一次内外状态翻转,而最后的状态又是在外部,所以当交奇数次,最开始状态和最后的状态相反,即在内部,同理当交偶数次,最开始在外部.

这道题中规定从该点向右的射线为判定线,当你搜索路径奇数次相交于点$i$的判定线,点$i$在路径多边形内部,反之在外部.

当这个点的状态从在外部变成在内部,总分数加上这个点的分值;当这个点的状态从在内部变成在外部,总分数减去这个点的分值,注意搜索过程中每走一步总分值要减一.

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 15, M = 1050;
int n, m, d, f[N][N][M], vis[N][N], in[N][N][M], x[N], y[N], bean[N], ans, dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};
struct node {int x, y, status;};
queue<node> q;
void solve(int fx, int fy) {
    memset(f, 0, sizeof(f)), memset(in, 0, sizeof(in));
    f[fx][fy][0] = 0, q.push((node){fx, fy, 0});
    while (!q.empty()) {
        node now = q.front();
        q.pop();
        for (int k = 0; k < 4; k++) {
            int nx = now.x + dx[k], ny = now.y + dy[k];
            if (nx <= 0 || nx > n || ny <= 0 || ny > m || vis[nx][ny]) continue;
            int status = now.status, score = f[now.x][now.y][now.status] - 1; // 注意减去移动的1步
            if (k < 2) {  // k<2时,上下移动才可能穿过右射线
                for (int i = 1; i <= d; i++) {  //枚举豆子
                    if (x[i] != min(nx, now.x) || y[i] > ny) continue; //没穿过这个豆子的右射线 or 经过这个豆子的左边
                    if (status >> i - 1 & 1) score -= bean[i];
                    else score += bean[i];
                    status ^= (1 << (i - 1));  //改变经过次数奇偶性
                }
            }
            if (!in[nx][ny][status])
                in[nx][ny][status]=1, f[nx][ny][status] = score, q.push((node){nx, ny, status});
        }
    }
    for (int i = 0; i < (1 << d); i++)
        if (in[fx][fy][i]) ans = max(ans, f[fx][fy][i]);
}
int main() {
    scanf("%d%d%d", &n, &m, &d);
    for (int i = 1; i <= d; i++) scanf("%d", &bean[i]);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            char c;
            scanf(" %c", &c);
            if (c == '#') vis[i][j] = -1;
            else x[c - '0'] = i, y[c - '0'] = j, vis[i][j] = c - '0';
        }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (!vis[i][j]) solve(i, j);
    printf("%d\n", ans);
    return 0;
}
```]]></description></item><item><title>POJ1852 Ants 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/14/poj1852.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Tue, 14 Apr 2020 07:07:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/14/poj1852.html</guid><description><![CDATA[# 题目

An army of ants walk on a horizontal pole of length l cm, each with a constant speed of 1 cm/s. When a walking ant reaches an end of the pole, it immediatelly falls off it. When two ants meet they turn back and start walking in opposite directions. We know the original positions of ants on the pole, unfortunately, we do not know the directions in which the ants are walking. Your task is to compute the earliest and the latest possible times needed for all ants to fall off the pole.

一群蚂蚁在长度为$1cm$的水平杆上行走，每只速度为$1 cm/s$。 当蚂蚁到达杆的一端时，它立即从杆上掉下来。当两只蚂蚁相遇时，他们转身开始向相反的方向行走。 我们知道蚂蚁在杆子上的原始位置，不幸的是，我们不知道蚂蚁的行走方向。 您的任务是计算所有蚂蚁掉下来所需的最长和最短的时间。

# 输入格式

The first line of input contains one integer giving the number of cases that follow. The data for each case start with two integer numbers: the length of the pole (in cm) and n, the number of ants residing on the pole. These two numbers are followed by n integers giving the position of each ant on the pole as the distance measured from the left end of the pole, in no particular order. All input integers are not bigger than 1000000 and they are separated by whitespace.

输入数据包含多组,输入的第一行包含一个整数，给出随后的组数。 每组的数据均以两个整数开头：杆的长度(以厘米为单位)和 $n$(杆上的蚂蚁数)。后面紧跟着$n$个整数，给出了每个蚂蚁在杆上的位置,从杆左端开始的距离(无特定顺序)。 所有输入整数均不大于1000000，并且它们之间用空格分隔。

# 输出格式

For each case of input, output two numbers separated by a single space. The first number is the earliest possible time when all ants fall off the pole (if the directions of their walks are chosen appropriately) and the second number is the latest possible such time.

对于每种输入情况，输出两个数字，并用一个空格隔开。 第一个数字是所有蚂蚁掉下来的最短时间（如果正确选择了它们的行走方向），第二个数字是最长时间。

# 题解

这道题很简单,由于两只蚂蚁相遇立即转头,和不考虑这个条件,两只蚂蚁相遇时互相穿过是等价的,所以直接考虑每只蚂蚁自己即可.

由于每只蚂蚁速度是$1 m/s$,所以时间数值上等于距离,我们只需要考虑距离即可

设第i只蚂蚁距离左端$L_i$,距离右端$R_i$

最长时间等于$max\{max (L_i,R_i)\}$

最短时间等于$max\{min (L_i,R_i)\}$

注意所有蚂蚁掉下来的时间等于最后一只蚂蚁掉下来的时间,所以所有蚂蚁的距离中取最大值

对于每只蚂蚁:

1. 最长时间取最大值,我们可以认为每只蚂蚁都很傻,选择最长的路走,然后最后一只蚂蚁掉下来的时间就是答案

2. 最短时间取最小值,我们可以认为每只蚂蚁都很聪明,选择最短的路走,然后最后一只蚂蚁掉下来的时间就是答案

# 代码

```cpp
#include<cstdio>
#include<algorithm>
inline int input(){int t;scanf("%d",&t);return t;}
int main(){
    for(int t=input();t--;){
        int l=input(),n=input(),maxv=0,minv=0,temp;
        for(int i=1;i<=n; i++)
            temp=input(),maxv=std::max(maxv,std::max(temp,l-temp)),minv=std::max(minv,std::min(temp,l-temp));
        printf("%d %d\n",minv,maxv);
    }
}
```]]></description></item><item><title>BZOJ 1131 [POI2008] STA-Station 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/12/bzoj-1131.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 12 Apr 2020 14:31:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/12/bzoj-1131.html</guid><description><![CDATA[# 题目

The first stage of train system reform (that has been described in the problem Railways of the third stage of 14th Polish OI.

However, one needs not be familiar with that problem in order to solve this task.) has come to an end in Byteotia. The system consists of bidirectional segments of tracks that connect railway stations. No two stations are (directly) connected by more than one segment of tracks.

Furthermore, it is known that every railway station is reachable from every other station by a unique route. This route may consist of several segments of tracks, but it never leads through one station more than once.

The second stage of the reform aims at developing train connections.

Byteasar count on your aid in this task. To make things easier, Byteasar has decided that:

one of the stations is to became a giant hub and receive the glorious name of Bitwise, for every other station a connection to Bitwise and back is to be set up, each train will travel between Bitwise and its other destination back and forth along the only possible route, stopping at each intermediate station.

It remains yet to decide which station should become Bitwise. It has been decided that the average cost of travel between two different stations should be minimal.

In Byteotia there are only one-way-one-use tickets at the modest price of  bythaler, authorising the owner to travel along exactly one segment of tracks, no matter how long it is.

Thus the cost of travel between any two stations is simply the minimum number of tracks segments one has to ride along to get from one stations to the other.

Task Write a programme that:

reads the description of the train system of Byteotia, determines the station that should become Bitwise, writes out the result to the standard output.

给出一个N个点的树,找出一个点来,以这个点为根的树时,所有点的深度之和最大

# 输入格式

给出一个数字$N$,代表有$N$个点.$N<=1000000$ 下面$N-1$条边.

# 输出格式

输出你所找到的点,如果具有多个解,请输出编号最小的那个.

# 题解

随便取一个点做根,比如1号节点,然后从1号节点出发dfs每个节点,算出每棵子树的大小和每个节点的深度

然后再一次dfs,树形dp,求每个点做根时,所有点的深度之和,然后输出最大值即可.

那么转移方程怎么考虑?

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200412223020163-2115390372.png)

这棵树从$fa$搜到$root$的时候,如何转移?

dp值的含义是所有点的深度,那么在树根从$fa$变成$root$时,所有点的深度之和怎么变化?

显然红色圈内所有点的深度+1,紫色圈内所有点深度-1

紫色圈内点数就是以$root$为根的子树的大小,记为$size$,则紫色圈内点数就是总点数减去$size$即$n-size$

所以转移方程就是:

$dp_{root} = dp_{fa} - size_{root} + (n-size_{root})
\\\ \ \ \ \ \ \ \ \ \ \ = dp_{fa} + n - 2 \times size_{root}
$

还要注意用`long long`

# 代码

```cpp
#include <cstdio>
const int maxn = 1000005;
int head[maxn], tot, n, ans, fa[maxn], size[maxn], ix, iy;
long long dp[maxn];
struct Edge { int to, next; } edges[maxn << 1];
inline int input() { int t; scanf("%d", &t); return t; }
void add(int x, int y) { edges[++tot].to = y; edges[tot].next = head[x]; head[x] = tot; }
void dfs(int root, int fa) {
    size[root] = 1;
    for (int x = head[root]; x; x = edges[x].next) {
        if (edges[x].to == fa) continue;
        dfs(edges[x].to, root);
        size[root] += size[edges[x].to];
        dp[root] += dp[edges[x].to] + size[edges[x].to];
    }
}
void dpf(int root, int fa) {
    if (root != 1) dp[root] = dp[fa] + n - size[root] * 2;
    for (int x = head[root]; x; x = edges[x].next)
        if (edges[x].to != fa) dpf(edges[x].to, root);
}
int main() {
    n = input();
    for (int i = 1; i < n; i++) add(ix = input(), iy = input()), add(iy, ix);
    dfs(1, 0), dpf(1, 0);
    for (int i = 1; i <= n; i++) if (dp[i] > dp[ans]) ans = i;
    printf("%d\n", ans);
}
```]]></description></item><item><title>HDU 5963 朋友 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/12/hdu-5963.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 12 Apr 2020 12:25:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/12/hdu-5963.html</guid><description><![CDATA[

# 题目

B君在围观一群男生和一群女生玩游戏，具体来说游戏是这样的：

给出一棵n个节点的树，这棵树的每条边有一个权值，这个权值只可能是0或1。 在一局游戏开始时，会确定一个节点作为根。接下来从女生开始，双方轮流进行操作。

当一方操作时，他们需要先选择一个不为根的点，满足该点到其父亲的边权为1; 然后找出这个点到根节点的简单路径，将路径上所有边的权值翻转(即0变成1，1 变成0)。

当一方无法操作时(即所有边的边权均为0)，另一方就获得了胜利。

如果在双方均采用最优策略的情况下，女生会获胜，则输出“Girls win!”，否则输 出“Boys win!”。

为了让游戏更有趣味性，在每局之间可能会有修改边权的操作，而且每局游戏指 定的根节点也可能是不同的。

具体来说，修改边权和进行游戏的操作一共有m个，具体如下：

- “0 x”表示询问对于当前的树，如果以x为根节点开始游戏，哪方会获得胜利。
- “1 x y z ”表示将x和y之间的边的边权修改为z。

B君当然知道怎么做啦！但是他想考考你。

# 输入格式

包含至多5组测试数据。

第一行有一个正整数，表示数据的组数。

接下来每组数据第一行，有二个空格隔开的正整数$n,m$，分别表示点的个数，操作个数。保证$n,m< 40000$。

接下来$n-1$行，每行三个整数$x,y,z$，表示树的一条边。保证$1<x<n, 1<y< n, 0 \le z \le 1$。

接下来$m$行，每行一个操作，含义如前所述。保证一定只会出现前文中提到的两种格式。
对于操作$0$，保证$1 \le x \le n$ ;对于操作1，保证$1 \le x \le n, 1 \le y \le n, 0 \le z \le 1$，保证树上存在一条边连接$x$和$y$。

# 输出格式

对于每组数据的每一个询问操作，输出一行“Boys win!”或者“Girls win!”。

# 输入样例

```cpp
2
2 3
1 2 0
0 1
1 2 1 1
0 2
4 11
1 2 1
2 3 1
3 4 0
0 1
0 2
0 3
0 4
1 2 1 0
0 1
0 2
0 3
1 3 4 1
0 3
0 4
```

# 输出样例

```
Boys win!
Girls win!
Girls win!
Boys win!
Girls win!
Boys win!
Boys win!
Girls win!
Girls win!
Boys win!
Girls win! 
```

# 题解
![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200412202446677-1972281194.png)



在这棵树上,无论是操作黄色,绿色还是灰色节点,都会使蓝色边的状态翻转

所以显然,无论操作哪个节点，都会使这棵子树与根直接相连的那条边状态翻转

而由题意,只要这棵子树与根直接相连的边是1,都可以翻转,如果是0,则不一定.

假设最开始是1,男生翻转为0,假设还可以翻转,女生就翻转为1,由于此时这条边是1,所以男生一定可以继续翻转,翻转后是0,一直翻转下去,男生一定不会输,而女生终究会遇到全变成0的情况,所以男生一定会赢.

总结规律就是,如果这条边最开始是1,先手一定赢;反过来也成立,如果这条边最开始是0,先手一定输.

那么就可以通过统计和根节点直接相连的边的状态来计算答案了.

如果是1的边的个数是奇数,先手一定赢,反之先手一定输

# 代码

注意`unordered_map`内部实现是哈希表,查询比普通`map`快($O(1)$),内部无序

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 4e4 + 5, maxt = 4e4 + 1;
unordered_map<int, int> a;
inline int input() {int t;scanf("%d", &t);return t;}
int main() {
    for (int t = input(); t--;) {
        int n = input(), m = input(), ans[maxn], key, x, y, z, u, v;
        vector<int> b[maxn];
        for (int i = 1; i < n; i++) {
            b[v=input()].push_back(u=input()),b[u].push_back(v);
            if (u > v) swap(u, v);
            a[u * maxt + v] = input();
        }
        for (int i = 1; i <= n; i++) {
            int s = 0;
            for (int j = 0; j < b[i].size(); j++) {
                int v = b[i][j], u = i;
                if (u > v) swap(u, v);
                s += a[u * maxt + v];
            }
            ans[i] = s & 1;
        }
        for (int i = 1; i <= m; i++) {
            if (key = input()) {
                if ((x=input()) > (y=input())) swap(x, y);
                if ((z=input()) != a[x * maxt + y]) ans[x] ^= 1, ans[y] ^= 1, a[x * maxt + y] = z;
            } else puts((ans[input()] & 1) ? "Girls win!" : "Boys win!");
        }
    }
    return 0;
}
```]]></description></item><item><title>Codeforces 1292C Xenon's Attack on the Gangs 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/11/codeforces-1292c.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sat, 11 Apr 2020 04:44:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/11/codeforces-1292c.html</guid><description><![CDATA[# 题目

On another floor of the A.R.C. Markland-N, the young man Simon "Xenon" Jackson, takes a break after finishing his project early (as always). Having a lot of free time, he decides to put on his legendary hacker "X" instinct and fight against the gangs of the cyber world.

His target is a network of $n$ small gangs. This network contains exactly $n−1$ direct links, each of them connecting two gangs together. The links are placed in such a way that every pair of gangs is connected through a sequence of direct links.

By mining data, Xenon figured out that the gangs used a form of cross-encryption to avoid being busted: every link was assigned an integer from $0$ to $n−2$ such that all assigned integers are distinct and every integer was assigned to some link. If an intruder tries to access the encrypted data, they will have to surpass $S$ password layers, with $S$ being defined by the following formula:

$$s=\sum_{1\le u \le v \le n} mex(u,v)$$

Here, $mex(u,v)$ denotes the smallest non-negative integer that does not appear on any link on the unique simple path from gang $u$ to gang $v$.

Xenon doesn't know the way the integers are assigned, but it's not a problem. He decides to let his AI's instances try all the passwords on his behalf, but before that, he needs to know the maximum possible value of $S$, so that the AIs can be deployed efficiently.

Now, Xenon is out to write the AI scripts, and he is expected to finish them in two hours. Can you find the maximum possible $S$ before he returns?

# 输入格式

The first line contains an integer $n (2 \le n \le 3000)$, the number of gangs in the network.

Each of the next n−1 lines contains integers $u_i$ and $v_i (1 \le u_i,v_i \le n; u_i \ne v_i)$, indicating there's a direct link between gangs $u_i$ and $v_i$.

It's guaranteed that links are placed in such a way that each pair of gangs will be connected by exactly one simple path.

# 输出格式

print the maximum possible value of $S$ — the number of password layers in the gangs' network.

# 样例输入1

```cpp
3
1 2
2 3
```

# 样例输出1

````cpp
3
````

# 样例输入1
```cpp
5
1 2
1 3
1 4
3 5
```
# 样例输出1

```cpp
10
```

# 注意

In the first example, one can achieve the maximum $S$ with the following assignment:

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200411124308895-453452417.jpg)



With this assignment, $mex(1,2)=0$, $mex(1,3)=24$ and $mex(2,3)=1$. Therefore, $S=0+2+1=3$.

In the second example, one can achieve the maximum $S$ with the following assignment:

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200411124313438-387250702.jpg)



With this assignment, all non-zero mex value are listed below:

- $mex(1,3)=1$
- $mex(1,5)=2$
- $mex(2,3)=1$
- $mex(2,5)=2$
- $mex(3,4)=1$
- $mex(4,5)=3$

Therefore, $S=1+2+1+2+1+3=10$.

# 题解

![](2.jpg)

看一下样例2

首先考虑边权为$0$的这条边,只要通过这条边的,最小的整数就是$1$了,那么经过这条边路径的个数就是$0$贡献的代价,即这条边右边的点数量乘左边点数量:$2 \times 3 = 6$

再考虑$1$,如果单独考虑它,经过它的最小整数是$0$,对答案没有一点贡献了,所以必须和1组合起来,那么把$0-1$看做一个整体,右边一个点,左边3个点,所以贡献就是$1 \times 3 = 3$

注意这里的贡献是1的原因是之前已经有一层1的贡献,这里是2的贡献,所以每条链只多了1的贡献

对于$2$,必须和$0,1$组合起来,而且只能考虑$2-0-1$这一条链,所以左边1个点,右边1个点,贡献就是$1 \times 1 = 1$

对于$3$,无法构成一条链,贡献就是$0$

所以加起来就是$10$,和样例输出一样

注意从小到大所有权值必须在一条链上,如果不够成一条链,比如$3$,最小整数就是$0$,相当于没有贡献了

简化模型,只考虑一条链

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200411124321447-892340971.png)


设$dp_{i,j}$为从$i$到$j$的$S$最大值

然后把左边的点数后右边点数的积加上中间的链的dp值,中间的dp值就可以用递归实现.

注意这里的递归可以使用记忆化搜索.

```cpp
#include <cstdio>
#include <cstring>
#define max(a, b) ((a) > (b) ? (a) : (b))
const int maxn = 3005;
long long dp[maxn][maxn], cnt[maxn][maxn], ans;
int fa[maxn][maxn], head[maxn << 1], next[maxn << 1], to[maxn << 1], n, x, y, ct;
void dfs(int x, int f, int root) {
    cnt[root][x] = 1;
    fa[root][x] = f;
    for (int i = head[x]; i; i = next[i]) {
        if (to[i] == f) continue;
        dfs(to[i], x, root);
        cnt[root][x] += cnt[root][to[i]];
    }
}
long long dpf(int x, int y) {
    if (x == y) return 0;
    if (dp[x][y] != -1) return dp[x][y];
    return dp[x][y] = cnt[y][x] * cnt[x][y] + max(dpf(fa[y][x], y), dpf(x, fa[x][y]));
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        scanf("%d%d", &x, &y);
        to[++ct] = --y, next[ct] = head[--x], head[x] = ct;
        to[++ct] = x, next[ct] = head[y], head[y] = ct;
    }
    for (int i = 0; i < n; i++) dfs(i, -1, i);
    memset(dp, -1, sizeof(dp));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) ans = max(ans, dpf(i, j));
    printf("%lld", ans);
}
```
]]></description></item><item><title>Emergency Evacuation 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/10/emergency-evacuation.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Fri, 10 Apr 2020 12:03:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/10/emergency-evacuation.html</guid><description><![CDATA[The Japanese government plans to increase the number of inbound tourists to forty million in the year 2020, and sixty million in 2030. Not only increasing touristic appeal but also developing
tourism infrastructure further is indispensable to accomplish such numbers. 

One possible enhancement on transport is providing cars extremely long and/or wide, carrying many passengers at a time. Too large a car, however, may require too long to evacuate all
passengers in an emergency. You are requested to help estimating the time required.

The car is assumed to have the following seat arrangement.
- A center aisle goes straight through the car, directly connecting to the emergency exit
door at the rear center of the car.
- The rows of the same number of passenger seats are on both sides of the aisle.
A rough estimation requested is based on a simple step-wise model. All passengers are initially
on a distinct seat, and they can make one of the following moves in each step.
- Passengers on a seat can move to an adjacent seat toward the aisle. Passengers on a seat
adjacent to the aisle can move sideways directly to the aisle.
- Passengers on the aisle can move backward by one row of seats. If the passenger is in front of the emergency exit, that is, by the rear-most seat rows, he/she can get off the car.

The seat or the aisle position to move to must be empty; either no other passenger is there before the step, or the passenger there empties the seat by moving to another position in the
same step. When two or more passengers satisfy the condition for the same position, only one of them can move, keeping the others wait in their original positions.

The leftmost figure of Figure C.1 depicts the seat arrangement of a small car given in Sample Input 1. The car have five rows of seats, two seats each on both sides of the aisle, totaling twenty. The initial positions of seven passengers on board are also shown.

The two other figures of Figure C.1 show possible positions of passengers after the first and the second steps. Passenger movements are indicated by fat arrows. Note that, two of the passengers in the front seat had to wait for a vacancy in the first step, and one in the second row had to wait in the next step.

Your task is to write a program that gives the smallest possible number of steps for all the passengers to get off the car, given the seat arrangement and passengers’ initial positions.

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200410200223213-665018728.png)



# 输入格式

The input consists of a single test case of the following format.

put consists of a single test case of the following format.

$
r\ s\ p\\
i_1\ j_1\\
.\\
.\\
.\\
i_p\ j_p\\
$

Here, $r$ is the number of passenger seat rows, $s$ is the number of seats on each side of the aisle, and $p$ is the number of passengers. They are integers satisfying $1 \le r \le 500, 1 \le s \le 500$, and $1 \le p \le 2rs$.

The following $p$ lines give initial seat positions of the passengers. The k-th line with ik and $jk$ means that the k-th passenger’s seat is in the ik-th seat row and it is the jk-th seat on that row.

Here, rows and seats are counted from front to rear and left to right, both starting from one.

They satisfy $1 \le ik \le r$ and $1 \le jk \le 2s$. Passengers are on distinct seats, that $i_s, i_k \ne i_l$ or $j_k \ne j_l$ holds if $k \ne l$.

# 输出格式

The output should be one line containing a single integer, the minimum number of steps required for all the passengers to get off the car.

# 样例输入1

```
5 2 7
1 1
1 2
1 3
2 3
2 4
4 4
5 2
```

# 样例输出1

```
9
```

# 样例输入2
```
500 500 16
1 1
1 2
1 999
1 1000
2 1
2 2
2 999
2 1000
3 1
3 2
3 999
3 1000
499 500
499 501
499 999
499 1000
```
# 样例输出2

```
1008
```

# 题解

这个题还有点绕,但是想通了之后就简单了

首先假设不会有人挡住别人,这样很容易求出来每个人的时间,但是这时候就会发现,会有人一起到达出口,而假设实际上是不成立的,所以需要依次延后.

比如某个时间有3个人同时到达了出口,那么这一秒只能有一个人出去,而剩下的两个人只能再接下来的两秒出去.

这又遇到一个问题,如果这两个人等待的时候,后面又有人被堵了,怎么办?只能继续延后,这样延后到都出去.

如果真的是一个一个出去的话,显然答案就是人数,但是实际上可能又空缺,而这个空缺数量也不难算,当出口出现堵塞的时候,看看最后延后到哪里,如果从现在到堵塞结束的时间都没有人到达出口,就出现了空缺.

把接下来第一个到达出口的时间和堵塞结束的时间相减,就得出了空缺大小,人数加上总的空缺大小,就是最后的答案

# 代码

```cpp
#include <cstdio>
#define max(a, b) ((a) > (b) ? (a) : (b))
int cnt[2010], r, s, p, y, x, last, ans;
int main() {
    scanf("%d%d%d", &r, &s, &p);
    for (int i = 1; i <= p; i++) {
        scanf("%d%d", &y, &x);
        cnt[max(s - x + 1, x - s) + r - y + 1]++;  // 下标是时间,记录这个时间有多少人到达出口(若人不挡人)
    }
    for (int i = 1; i < 2010; i++)
        if (cnt[i])
            if (last >= i - 1) // last是堵塞结束的时间
                last = cnt[i] + last;  // 继续延后
            else {
                ans += i - last - 1;  // 记录空缺
                last = i - 1 + cnt[i];  // 更新last
            }
    printf("%d", ans + p);
    return 0;
}
```]]></description></item><item><title>P4408 逃学的小孩 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/09/P4408.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Thu, 09 Apr 2020 04:37:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/09/P4408.html</guid><description><![CDATA[# 题目描述

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200409123649470-1074326152.jpg)

Chris家的电话铃响起了，里面传出了Chris的老师焦急的声音：“喂，是Chris的家长吗？你们的孩子又没来上课，不想参加考试了吗？”一听说要考试，Chris的父母就心急如焚，他们决定在尽量短的时间内找到Chris。他们告诉Chris的老师：“根据以往的经验，Chris现在必然躲在朋友Shermie或Yashiro家里偷玩《拳皇》游戏。现在，我们就从家出发去找Chris，一但找到，我们立刻给您打电话。”说完砰的一声把电话挂了。

Chris居住的城市由N个居住点和若干条连接居住点的双向街道组成，经过街道x需花费Tx分钟。可以保证，任两个居住点间有且仅有一条通路。Chris家在点C，Shermie和Yashiro分别住在点A和点B。Chris的老师和Chris的父母都有城市地图，但Chris的父母知道点A、B、C的具体位置而Chris的老师不知。

为了尽快找到Chris，Chris的父母会遵守以下两条规则：

如果A距离C比B距离C近，那么Chris的父母先去Shermie家寻找Chris，如果找不到，Chris的父母再去Yashiro家；反之亦然。
Chris的父母总沿着两点间唯一的通路行走。
显然，Chris的老师知道Chris的父母在寻找Chris的过程中会遵守以上两条规则，但由于他并不知道A，B，C的具体位置，所以现在他希望你告诉他，最坏情况下Chris的父母要耗费多长时间才能找到Chris？

# 输入格式

输入文件第一行是两个整数$N（3 ≤ N ≤ 200000）$和$M$，分别表示居住点总数和街道总数。

以下M行，每行给出一条街道的信息。第$i+1$行包含整数$U_i、V_i、T_i（1≤U_i, V_i ≤ N，1 ≤ T_i ≤ 1000000000）$，表示街道i连接居住点$U_i$和$V_i$，并且经过街道i需花费$T_i$分钟。街道信息不会重复给出。

# 输出格式

输出文件仅包含整数T，即最坏情况下Chris的父母需要花费T分钟才能找到Chris。

# 输入样例

```
4 3
1 2 1
2 3 1
3 4 1
```

# 输出样例

```
4
```

# 题解

好久没见过思路这么简单的题了<span class="heimu">,但该WA还是要WA</span>

首先这个图是一棵树

然后就很明确了,显然是树的直径,情况最差的时候,A点和B点之间的路径就是树的直径,然后C点就是使$min(distance_{C,A},distance_{C,B})$最大的C点.

首先DFS求出树的直径,然后遍历每一个点作为C点求出$distance_{C,A},distance_{C,B}$,然后根据刚才的式子推出来即可.

有几个需要注意的点:

```
9 8
1 8 1000000000
8 7 1000000000
7 5 1000000000
1 3 1000000000
7 2 1000000000
1 6 1000000000
3 4 1000000000
8 9 1000000000
```
对于这个输入,应该输出`8000000000`,如果你输出的是负数说明你没有开`long long`.

直接些会TLE,在求距离的函数那里加一个记忆化即可

<span class="heimu">怎么感觉我写不是正解,代码也太丑了</span>

再附赠一个数据:

输入:

```
4 3
1 2 1
1 3 1
1 4 2
```

输出:
`
5
`
# 代码

```cpp
#include <cstdio>
#include <iostream>
#include <map>
#include <utility>
#define P pair<int, int>
using namespace std;
const int maxn = 200005;
int head[maxn], tot, maxi, n, m, ix, iy, iv;
long long maxv;
struct Edge {
    int to, next;
    long long value;
} edges[maxn << 1];
void add(int x, int y, long long value) {
    edges[++tot].to = y;
    edges[tot].next = head[x];
    edges[tot].value = value;
    head[x] = tot;
}
void dfs(int root, int fa, long long dis) {
    if (dis > maxv) maxv = dis, maxi = root;
    for (int x = head[root]; x; x = edges[x].next)
        if (edges[x].to != fa) dfs(edges[x].to, root, dis + edges[x].value);
}
map<P, long long> save;
long long getd(int root, int fa, int target) {
    if (root == target) return 0;
    if(save.count(make_pair(root, target)))return save[make_pair(root, target)];
    for (int x = head[root]; x; x = edges[x].next) {
        if (edges[x].to == fa) continue;
        long long r = getd(edges[x].to, root, target);
        if (r != -1) {
            save[make_pair(edges[x].to, target)] = r;
            return r + edges[x].value;
        }
    }
    return -1;
}
int main() {
    scanf("%d%d", &n, &m);
    while (m--) {
        scanf("%d%d%d", &ix, &iy, &iv);
        add(ix, iy, iv);
        add(iy, ix, iv);
    }
    dfs(1, 0, 0);
    int d1 = maxi;
    maxv = 0, maxi = 0;
    dfs(d1, 0, 0);
    int d2 = maxi;
    long long cmaxv = 0;
    int cmaxi = 0;
    for (int i = 1; i <= n; i++)
        if (i != d1 && i != d2)
            cmaxv = max(cmaxv, min(getd(i, 0, d1), getd(i, 0, d2)));
    printf("%lld\n", cmaxv + maxv);
    return 0;
}
```
]]></description></item><item><title>UVA11300 Spreading the Wealth 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/09/UVA11300.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 08 Apr 2020 16:00:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/09/UVA11300.html</guid><description><![CDATA[# 题目

A Communist regime is trying to redistribute wealth in a village. They have have decided to sit everyone around a circular table. First, everyone has converted all of their properties to coins of equal value, such that the total number of coins is divisible by the number of people in the village. Finally, each person gives a number of coins to the person on his right and a number coins to the person on his left, such that in the end, everyone has the same number of coins. Given the number of coins of each person, compute the minimum number of coins that must be transferred using this method so that everyone has the same number of coins.

一个村庄重新分配财富。 他们已经决定让每个人围坐在一张圆桌旁。 首先，每个人都将其所有财产转换为等值的硬币，这样硬币的总数就可被村庄中的人数整除。 最后，每个人都给右边的人一些硬币，给左边的人一些硬币，每个人都有相同数量的硬币。 给定每个人的硬币数量，计算必须使用此方法转移的最小硬币数量，以便每个人都拥有相同数量的硬币。

# 输入格式

There is a number of inputs. Each input begins with $n (n < 1000001)$, the number of people in the village. n lines follow, giving the number of coins of each person in the village, in counterclockwise order around the table. The total number of coins will fit inside an unsigned 64 bit integer.

有多组输入。 每个输入均以数字$n（n <1000001）$开头，即人数.接下来$n$行，以逆时针方向给出村庄中每个人的硬币数量。 硬币总数将是一个无符号的64位整数。

# 输出格式

For each input, output the minimum number of coins that must be transferred on a single line.

对于每组输入，输出转移的最小硬币数。

# 输入样例

```
3
100
100
100
4
1
2
5
4
```

# 输出样例

```
0
4
```

# 题解

这道题感觉有点像数学题啊

因为一个人只能左右传硬币,所以只需要考虑左右

而每个人最开始的硬币数和最终的硬币数都是已知的,所以列方程即可


![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200408235909813-1045019349.png)



**设$coin_i$为最开始每个人的硬币数量,$pass_i$为第$i$个人给逆时针方向的人($i-1$)的硬币数量,$x$为最终每个人的硬币数量.**

这时候可能有的人就会疑惑了,为啥只给逆时针方向的人不给顺时针方向的人?

我们假设一下,$1$号给$2$号$5$个硬币,$2$号给$1$号$3$个硬币,一共转移了$8$个硬币,何必这么麻烦?直接让$1$号给$2$号$2$个硬币不就得了? 这样只需要转移$2$个硬币了.

注意,这个硬币数量可以是负数,也就是说,$1$号给$6$号$-2$个硬币,相当于6号给1号$2$个硬币

所以,相邻两人之间只会有一次硬币转移.

那我们擦去顺时针的:

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200408235916616-1039707553.png)



然后就可以开始列式子了:

$x=coin_1+pass_2-pass_1$

$x=coin_2+pass_3-pass_2$

$\dots$

$x=coin_n+pass_1-pass_n$

移项

$pass_2=x-coin_1+pass_1$

$pass_3=x-coin_2+\bm{pass_2}
\\ \ \ \ \ \ \ \ \ \ \ = x-coin_2+\bm{x_1-coin_1+pass_1}
$

$\dots$

由题意,我们应该让$\sum_{i=1}^n pass_i$最小

为了方便描述,再设一个数组$b_i$,使$b_0=0$,$b_i=coin_i+b_{i-1}-x$

这样就可以方便的表示$pass_i$,再表示一遍

$pass_2=pass_1+x-coin_1
\\ \ \ \ \ \ \ \ \ \ \ = pass_1 - (coin_1-x)
\\ \ \ \ \ \ \ \ \ \ \ = pass_1 - b_1
$

$pass_3=\bm{pass_2}+x-coin_2
\\ \ \ \ \ \ \ \ \ \ \ = \bm{pass_1 - b_1} +x - coin_2
\\ \ \ \ \ \ \ \ \ \ \ = pass_1 - (\bm{coin_2+b_1-x})
\\ \ \ \ \ \ \ \ \ \ \ = pass_1 - \bm{b_2}
$

$\dots$

所以

$\sum_{i=1}^npass_i = pass_1+pass_2+pass_3+\dots+pass_n
\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ = |pass_1 - b_1|+|pass_1 - b_2| + \dots + |pass_1 - b_{n-1}|
$

注意,这个式子相当于数轴上$b_1,b_2,b_3,b_4\cdots$到$pass_1$的距离之和,那么使这个距离之和最小即可

这里我们可以就用中位数的性质了:

>在数轴上所有n个点中，中位数离所有点的距离之和最小

求出最小的和输出即可

## 理解

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200409181111493-1262452577.png)



对于这个数轴,中位数为2,与其他点距离的和为6

如果不选择中位数,比如选择1,那么与其他点距离的和为7

形象的理解,当$pass_1$向左移动一个单位长度时,虽然有两个点的距离缩小了$d$,但是有3个点的距离增加了$d$,显然结果变大

若移动两个单位长度,同理结果大于移动一个单位长度,所以当选择中位数时,结果最小.

如果出现偶数个点,

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200409181117517-29349220.png)

$[2,3]$中任意一个点皆可做$pass_1$,由于$pass_1$为整数并且为了写代码方便,取端点值即可

## 证明

1. 给定一个从小到大的数列$x_1,x_2,\dots x_n$

2. 设$x$是从$x1$到$x_n$与其绝对差之和最小的数.

3. 当$x$在$x_1$与$x_n$之间,$x$与$x_1$,$x_n$的距离和就是$x_1$到$x_n$的距离,
若不在$x_1$与$x_n$之间,$x$与$x_1$,$x_n$的距离和还要额外加上一段,
则$x$位于$x_1$与$x_n$之间.

4. 由于$x_1, x_n$与它们之间的任意一点的距离之和($|x_i-x_1|+ |x_i- x_n$|)都相等，等于$x_n一x_1$，因此不需要考虑$x_1, x_n$.

5. 由第3点可得,$x$位于$x_2$与$x_{n-1}$之间,且$x$与$x_2,x_{n-1}$的距离和相等,不需要考虑.

6. 依次类推，$x$就是该数列中间的那个数，或者是中间的那两个数之一， 而这个数就是中位数.


# 代码
```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
const int maxn = 1000000 + 10;
long long coin[maxn], b[maxn], tot, x;
int main() {
    int n;
    while (~scanf("%d", &n)) {
        tot = b[0] = 0;
        for (int i = 1; i <= n; i++) {
            scanf("%lld", &coin[i]);
            tot += coin[i];
        }
        x = tot / n;
        for (int i = 1; i < n; i++) b[i] =  coin[i] + b[i - 1] - x;
        sort(b, b + n);
        long long mid = b[n / 2], ans = 0;
        for (int i = 0; i < n; i++) ans += abs(mid  - b[i]);
        printf("%lld\n", ans);
    }
    return 0;
}
```
]]></description></item><item><title>功能</title><link>http://www.cnblogs.com/youxam/archive/2020/04/08/a.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Wed, 08 Apr 2020 10:58:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/08/a.html</guid><description><![CDATA[- [go1.14.1.linux-amd64.tar.rar.z09.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z09.zip)
- [go1.14.1.linux-amd64.tar.rar.z08.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z08.zip)
- [go1.14.1.linux-amd64.tar.rar.z07.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z07.zip)
- [go1.14.1.linux-amd64.tar.rar.z06.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z06.zip)
- [go1.14.1.linux-amd64.tar.rar.z05.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z05.zip)
- [go1.14.1.linux-amd64.tar.rar.z04.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z04.zip)
- [go1.14.1.linux-amd64.tar.rar.z03.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z03.zip)
- [go1.14.1.linux-amd64.tar.rar.z02.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z02.zip)
- [go1.14.1.linux-amd64.tar.rar.z01.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.z01.zip)
- [go1.14.1.linux-amd64.tar.rar.zip](https://files.cnblogs.com/files/youxam/go1.14.1.linux-amd64.tar.rar.zip)


[鑫考云](https://files.cnblogs.com/files/youxam/xky.js)
]]></description></item><item><title>P2882 Face The Right Way G 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/07/P2882.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Tue, 07 Apr 2020 04:48:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/07/P2882.html</guid><description><![CDATA[# 题目
Farmer John has arranged his N $(1 ≤ N ≤ 5,000)$ cows in a row and many of them are facing forward, like good cows. Some of them are facing backward, though, and he needs them all to face forward to make his life perfect.

Fortunately, FJ recently bought an automatic cow turning machine. Since he purchased the discount model, it must be irrevocably preset to turn K $(1 ≤ K ≤ N)$ cows at once, and it can only turn cows that are all standing next to each other in line. Each time the machine is used, it reverses the facing direction of a contiguous group of K cows in the line (one cannot use it on fewer than K cows, e.g., at the either end of the line of cows). Each cow remains in the same **location** as before, but ends up facing the **opposite direction**. A cow that starts out facing forward will be turned backward by the machine and vice-versa.

Because FJ must pick a single, never-changing value of K, please help him determine the minimum value of K that minimizes the number of operations required by the machine to make all the cows face forward. Also determine M, the minimum number of machine operations required to get all the cows facing forward using that value of K.

N头牛排成一列$1<=N<=5000$。每头牛或者向前或者向后。为了让所有牛都 面向前方，农夫每次可以将K头连续的牛转向$1<=K<=N$，求操作的最少次数M和对应的最小K。

# 输入格式

Line 1: A single integer: $N$

Lines $2..N+1$: Line $i+1$ contains a single character, F or B, indicating whether cow $i$ is facing forward or backward.

第一行一个整数N
第2行至$N+1$行是一个字符,F或B,表示向前或向后.

# 输出格式

Line 1: Two space-separated integers: $K$ and $M$

一行两个数字,$K$和$M$

# 输入样例

```
7
B
B
F
B
F
B
B
```
# 输出样例

```
3 3
```

# 题解

很容易想到暴力解法,三层循环,一层枚举$k$,一层遍历从前往后遍历数组,一遇到向后的牛就一层循环反转后面长度为k的数组,时间复杂度$O(n^3)$,显然不行,那么就需要优化.

看最后一层循环,可以使用差分优化,每次反转就将次数+1,由于反转两次相当于没有反转,所以就可以根据次数和原本的状态推出反转后的状态.

不需要开一个前缀和数组,因为从前往后遍历,只需要定义一个`sum`变量存储前缀和,一边累计前缀和一边修改差分数组即可.



# 代码

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 5010, INF = 1e9;
int n, r, a[maxn], f[maxn];
int check(int k) {
    memset(f, 0, sizeof(f));
    int sum = 0, ans = 0;
    for (int i = 1; i <= n; ++i) {
        if (~(a[i] + sum) & 1) { // 如果 a[i] + flag 为偶数
            if (i + k - 1 > n) return INF + 1; //超过限制, 返回最大值以保证答案不更新
            f[i] ++, f[i + k - 1] --, ans++;
        }
        sum += f[i];
    }
    return ans;
}
int main() {
    scanf("%d", &n);
    char status;
    for (int i = 1; i <= n; i++) getchar(), a[i] = getchar() == 'B' ? 0 : 1;
    int maxv = INF, ansk = n;
    for (int k = 1; k <= n; k++) if ((r = check(k)) <= maxv) maxv = r, ansk = k;
    printf("%d %d\n", ansk, maxv);
    return 0;
}
```

# 附

<span class="heimu">又到了水的时间</span>

介绍一些我觉得有意思的小技巧,可以让你的代码看起来更简洁<span class="heimu">难懂</span>

1. 判断一个数字奇偶

正常操作自然是模2看结果是0还是1,但是你是否感觉加一个`==0`或`==1`太累赘呢?如果想要`a`为奇数时表达式为真,可以直接使用`a%2`.如果想要偶数时表达式为真,可以使用`!(a%2)`.

但是后面这个这个又不美观了,要知道`if`,`while`等语句的条件也是要加括号的,如果想要偶数时表达式为真,代码可能会变成这样:

```cpp
if(!(a%2)){
    //do something
}
```
双层括号套一起,太丑了,这时候建议使用位运算,我们要知道一个整数为奇数时,其二进制表示最低位为1,反之为0,那么对这个整数与1取最低位,就可以判断奇偶

如果想要`a`为奇数时表达式为真,可以使用`a&1`.如果想要偶数时表达式为真,可以使用`~a&1`

同样是上面那种情况

```cpp
if(~a&1){
    //do something
}
```

看起来是不是更清爽<span class="heimu">让人看不懂</span>了呢?

2. 合理使用`getchar()`

由于`scanf`和`cin`的返回值不是输入值,所以不能直接放在条件表达式里,但是`getchar()`却不一样,像这种输入字符表示状态的题,可以使用`getchar()`来获取输入

```cpp
getchar(), a[i] = getchar() == 'B' ? 0 : 1;
```

第一个getchar()是读取回车符,然后用三元运算符判断输入,B为0,F为1

3. 当条件表达式和语句块内都使用函数返回值

由于当更新答案时,还要执行其它操作,不能用`max`,`min`函数,所以需要使用if语句

这里的情况就是

```cpp
int r=check(k);
if (r <= maxv) maxv = r, ansk = k;
```
第一行看起来就不爽,想干掉它,但是如果改成:

```cpp
if (check(k) <= maxv) maxv = check(k), ansk = k;
```
调用两次函数浪费了时间显然不能选

这时候注意,赋值语句也是有返回值的!其实也能算表达式?

所以你可以这么写(r变量先定义好):
```cpp
if ((r = check(k)) <= maxv) maxv = r, ansk = k;
```
]]></description></item><item><title>P3574 FAR-FarmCraft 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/06/P3574-FAR-FarmCraft.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Mon, 06 Apr 2020 14:36:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/06/P3574-FAR-FarmCraft.html</guid><description><![CDATA[# 题目

In a village called Byteville, there are $n$ houses connected with $n-1$ roads.

For each pair of houses, there is a unique way to get from one to another.

The houses are numbered from $1$ to $n$.

The house no. 1 belongs to the village administrator Byteasar.

As part of enabling modern technologies for rural areas framework, nn computers have been delivered to Byteasar's house.

Every house is to be supplied with a computer, and it is Byteasar's task to distribute them.

The citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers.

Byteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods.

He has just the right amount of gasoline to drive each road twice.

In each house, Byteasar leaves one computer, and immediately continues on his route.

In each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft.

The time it takes to install and set up the game very much depends on one's tech savviness, which is fortunately known for each household.

After he delivers all the computers, Byteasar will come back to his house and install the game on his computer.

The travel time along each road linking two houses is exactly 1 minute, and (due to citizens' eagerness to play) the time to unload a computer is negligible.

Help Byteasar in determining a delivery order that allows all Byteville's citizens (including Byteasar) to start playing together as soon as possible.

In other words, find an order that minimizes the time when everyone has FarmCraft installed.

在一个叫做比特村的小村庄中，有$n-1$条路连接着这个村庄中的全部nn个房子。

每两个房子之间都有一条唯一的通路。这些房子的编号为$1$至$n$。

1号房子属于村庄的管理员比特安萨尔。

为了提升村庄的科技使用水平，$n$台电脑被快递到了比特安萨尔的房子。每个房子都应该有一台电脑，且分发电脑的任务就落在了比特安萨尔的肩上。

比特村的居民一致同意去玩农场物语这个游戏的最新快照版，而且好消息是他们很快就要得到他们最新的高配置电脑了。

比特安萨尔将所有电脑都装在了他的卡车上，而且他准备好完成这个艰巨的任务了。

他的汽油恰好够走每条路两遍。

在每个房子边，比特安萨尔把电脑贴心的配送给居民，且立即前往下一个房子。（配送过程不花费任何时间）

只要每间房子的居民拿到了他们的新电脑，它们就会立即开始安装农场物语。安装农场物语所用的时间根据居民的科技素养而定。幸运的是，每间房子中居民的科技素养都是已知的。

在比特安萨尔配送完所有电脑后，他会回到他自己的1号房子去安装他自己的农场物语。

用卡车开过每条路的时间恰好是1分钟，而居民开电脑箱的时间可以忽略不计。（因为他们太想玩农场物语了）

请你帮助比特安萨尔算出从开始配送到所有居民都玩上了农场物语的最少时间。

# 输入格式
The first line of the standard input contains a single integer $n(2\le n\le 500\ 000)$ that gives the number of houses in Byteville.

The second line contains $n$ integers $c_1,c_2,\cdots,c_n(1\le c_i\le 10^9)$,separated by single spaces; $c_i$ is the installation time (in minutes) for the dwellers of house no. i.

The next $n-1$ lines specify the roads linking the houses.

Each such line contains two positive integers aa and $b (1\le a<b\le n)$, separated by a single space.These indicate that there is a direct road between the houses no. aa and bb.

第一行包含一个整数$n(2 \leq n \leq 500000)$，代表比特村中有多少房子。

第二行包含nn个整数$c_1, c_2, ⋯, c_n(1 \leq c_i \leq 10^9)$，每个数都被单个空格隔开。$c_i$是第i号房间中居民安装农场物语所用的时间。

接下来的n-1n−1行代表了每一条路的两个顶点。两个顶点$a$和$b$满足$(1 \leq a < b \leq n)$，两个数之间有一个空格。

# 输出格式

The first and only line of the standard output should contain a single integer:

the (minimum) number of minutes after which all citizens will be able to play FarmCraft together.


一行，包含一个整数，代表题目中所说的最小时间。

# 输入样例

```
6
1 8 9 6 3 2
1 3
2 3
3 4
4 5
4 6
```

# 输出样例

```
11
```

# 样例解释

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406223540389-118791411.png)



# 题解

前几天刚写过[salesman](https://www.cnblogs.com/youxam/p/bzoj4472.html),一看这题就觉得有点相似,主要是DFS的过程相似

对于一棵子树的根节点来说,已知遍历时间和装软件时间,我们该怎么分配遍历的顺序?

首先明确,要输出的答案是遍历所有子树且所有子树安装好软件的时间,那么,有没有可能比特安萨尔已经遍历完成,但是因为某些技术水平不高的居民而不得不继续等待耗费时间的情况?有可能,那么为了尽可能减少这个时间,我就先遍历那些技术水平不高的居民.

注意,如果安装时间最长,但需要遍历的时间也很长,不一定需要先遍历,因为遍历是一定需要遍历的,这些时间不能节省,遍历是比特安萨尔去遍历,一个人同时只能干一件事情,但安装是居民安装,可以同时多个居民同时安装.

如果本来可以同时安装但我让他尽可能多地同时安装,就会浪费时间.

所以我们应该先遍历的是总时间减遍历时间最大的,这些时间就是从DFS完成,回溯开始到软件安装完成的时间.这些时间可以用来遍历别的子树.

看一下这个图:

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406223546744-2069295504.png)



每一行代表一个居民的时间分配.

黄色是遍历时间,蓝色是安装时间.黄色首尾相接代表只能同时遍历一棵子树,蓝色可以重叠表示居民可以同时安装,

上面一块是没有优化的版本,可以看出来4号居民的安装时间大大拖慢了总体时间

下面是优化过的,可以看出来4号居民长长的安装时间是和遍历同时进行的,没有拖慢时间.

所以更新子树时,根据总时间减遍历时间从大到小排序即可.

# 代码

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;
const int maxn = 500001;
struct Edge {
    int to, next;
} edges[maxn<<1];
int n, head[maxn], cnt, u, v, a[maxn], dp[maxn], dis[maxn], son[maxn];
bool cmp(int x, int y) { return dp[x] - dis[x] > dp[y] - dis[y]; }
void add(int u, int v) { edges[++cnt].to = v, edges[cnt].next = head[u], head[u] = cnt; }
void dfs(int root, int fa) {
    if (root != 1) dp[root] = a[root];
    for (int i = head[root]; i; i = edges[i].next)
        if (edges[i].to != fa) dfs(edges[i].to, root);
    int sonn = 0;
    for (int x = head[root]; x; x = edges[x].next)
        if (edges[x].to != fa) son[++sonn] = edges[x].to;
    sort(son + 1, son + sonn + 1, cmp);
    for (int i = 1; i <= sonn; ++i)    
        dp[root] = max(dp[root], dp[son[i]] + dis[root] + 1), dis[root] += dis[son[i]] + 2;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    for (int i = 1; i < n; ++i) {
        scanf("%d%d", &u, &v);
        add(u, v);
        add(v, u);
    }
    dfs(1, 0);
    printf("%d\n", max(dp[1], dis[1] + a[1]));
    return 0;
}
```
]]></description></item><item><title>使用油猴脚本优化博客阅读体验</title><link>http://www.cnblogs.com/youxam/archive/2020/04/06/ban-blog.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Mon, 06 Apr 2020 05:45:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/06/ban-blog.html</guid><description><![CDATA[# 前言

我们在阅读他人的博客的时候,经常见到一些花里胡哨的功能,比如看板娘啦,鼠标特效啦之类的,我个人是很反感这些的,觉得这些东西破坏了阅读体验.与其搞这些,不如把界面弄得清爽点

那么这篇文章就教你用油猴脚本去掉这些功能

就拿我同学的博客开刀吧(手动滑稽)

修改前:

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406134403851-129527996.png)


![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406134410134-84081638.png)


修改后

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406134416229-355262622.png)


![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406134422013-2021509604.png)




# 油猴脚本初始化

如果没有下载油猴插件的,在[谷歌应用店](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo)下载.

下载好之后,新建脚本,在match属性中把要执行脚本的url填上去,注意通配符,一般来说,博客主页url后面加个星号即可.

# 音乐播放器

第一次点进去,就被自动播放的音乐吓了一跳,就算搞播放音乐也不要弄自动播放,还是很烦人的.

开发人员工具查看一下播放器的静音键,`class`为`aplayer-icon-volume-down`,添加以下代码

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406134427623-84782278.png)



注意一定要包裹在`window.onload`中,因为这个播放器也是js加载的,静音后删除整个播放器.

```js
window.onload=()=>{
    $(".aplayer-icon-volume-down").click();
    $(".aplayer-body").remove();
}
```

# 鼠标特效

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406134433575-804362311.png)



就是鼠标点击出现文字的特效,查看代码后发现没有`class`也没有`id`,只能直接看源代码,`network`标签中搜索文字,就直接查到代码

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406134439499-1029638518.png)



粗略看一下,可以发现每次用`a_idx`作为下标取`a`数组中一个元素显示,那么建立一个定时器,持续赋值`a_idx`为`-1`,在js中,下标为负时返回`undefined`.

```js
setInterval(()=>{window.a_idx=-1},100)
``` 

# 雪花

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406134445863-938517111.png)



其id为`snowbox`,有两种办法,一种借助css,直接隐藏

```js
$("body").append($("<style>#snowbox{display:none !important;}</style>"))
```

还可以加个定时器,不断删除,定时器时间自己调整就好

```js
setInterval(()=>{$("#snowbox").remove()},50)
```

# 其它元素

其他的元素都有class或者id,使用开发人员工具查看后直接隐藏即可

```js
$("body").append($(`<style>#jsi-flying-fish-container,#sidebar_topdiggedposts,
#sidebar_topcommentedposts,.catListComment,#catListLink,#sidebar_search,
#sidebar_news,.img_avatar,.pome,#blog-calendar,#post_next_prev,#author_profile,
#blog_post_info,#MySignature,#cnblogs_post_body > div[style='text-align: right'],
#back-top,#div_digg,#waifu,#player,#snowbox{display:none !important;}</style>`))
```

# 背景

将背景改为纯白

```js
$("body").append($(`<style>body{background:#fff !important;}</style>`))
```

完成!

# 所有代码

```js
// ==UserScript==
// @name         banblog
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  huaji
// @author       YouXam
// @match        https://www.cnblogs.com/DarthVictor/*
// @grant        none
// ==/UserScript==

(function() {
    'use strict';
   $("body").append($(`<style>#jsi-flying-fish-container,#sidebar_topdiggedposts,
#sidebar_topcommentedposts,.catListComment,#catListLink,#sidebar_search,
#sidebar_news,.img_avatar,.pome,#blog-calendar,#post_next_prev,#author_profile,
#blog_post_info,#MySignature,#cnblogs_post_body > div[style='text-align: right'],
#back-top,#div_digg,#waifu,#player,#snowbox{display:none !important;}</style>`));
    $("body").append($(`<style>body{background:#fff !important;}</style>`))
    window.onload=()=>{
        setInterval(()=>{window.a_idx=-1},100)
        $(".aplayer-icon-volume-down").click();
    }
})();
```]]></description></item><item><title>P2585 三色二叉树 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/06/P2585.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 05 Apr 2020 16:54:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/06/P2585.html</guid><description><![CDATA[# 题目

一棵二叉树可以按照如下规则表示成一个由0、1、2组成的字符序列，我们称之为"二叉树序列S"：



$$ 
S=\left\{
\begin{aligned}
0 &\ \ 表示该树没有子节点 \\
1S_1 &\ \ 表示该树有一个子节点,S_1为其子树的二叉树序列 \\
2S_1S_2 &\ \ 表示该树有两个子节点,S_1和S_2分别表示其两个子树的二叉树序列
\end{aligned}
\right.
$$

例如，下图所表示的二叉树可以用二叉树序列`S=21200110`来表示:

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200406005335756-1308208521.png)

你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不相同。给定一棵二叉树的二叉树序列，请求出这棵树中最多和最少有多少个点能够被染成绿色

# 输入格式

输入文件仅有一行，不超过$5\times 10^5$个字符，表示一个二叉树序列

# 输出格式

输出文件也只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色

# 输入样例

```
1122002010
```

# 输出样例

```
5 2
```
# 题解

直接用输入DFS来树形DP.

定义`maxv`和`minv`两个数组,`maxv[i][j]`表示以$i$号节点为根节点的子树最多能染成绿色的节点数量,当$j=0$,根节点被染成绿色;当$j=1$,根节点被染成红色;当$j=2$,根节点被染成蓝色.

`minv`类似,代表最少能染成绿色的节点数量.

当根节点有一个子节点时,这个子节点不能和根节点一个颜色,所以从剩下的两种颜色中挑选最大的更新.注意当根节点为绿色时,dp值需要加1(多了根节点一个绿色节点)

当根节点有两个子节点时,这两个子节点不能和根节点一个颜色,而又只剩下两种颜色,所以有两种情况,从这两种情况中选最大的更新即可.同样注意当根节点为绿色时的情况.

那么,怎么DFS这一个特殊序列?

首先可以确定的是,根节点就是第一项,那么通过第一项可以得知根节点有几个子树,如果这棵树不为空,那么左子树的根节点一定是第二项,注意如果只有一棵子树,那么我把唯一的一棵子树看作左子树.

再对左子树进行相同的递归操作,遇到0回溯,因为保证叶节点一定为0,所以不需要检查边界,回溯的时候,可以返回这棵子树在序列中最后一项的位置,这个位置加一就是右子树(如果有两棵子树).

以此类推,就能在不建树的情况下DFS它


# 代码

```cpp
#include <iostream>
#include <string>
using namespace std;
const int maxn = 10005;
string s;
int maxv[maxn][3], minv[maxn][3];
int dfs(int root) {
    if (s[root] == '0') {
        maxv[root][0] = minv[root][0] = 1;  // 因为叶节点没有子树,所以若该叶节点不为绿色,这棵子树中绿色节点的个数为0,反之为1
        return root;  // 这棵子树的结尾坐标
    }
    int lend = dfs(root + 1);  // 递归左子树
    if (s[root] == '1') {
        maxv[root][0] = max(maxv[root+1][1],maxv[root+1][2])+1;  // 这个是绿色的,需要额外算上根节点
        maxv[root][1] = max(maxv[root+1][0],maxv[root+1][2]);  // 这两种代表什么颜色其实无关紧要
        maxv[root][2] = max(maxv[root+1][0],maxv[root+1][1]);
        minv[root][0] = min(minv[root+1][1],minv[root+1][2])+1;
        minv[root][1] = min(minv[root+1][0],minv[root+1][2]);
        minv[root][2] = min(minv[root+1][0],minv[root+1][1]);
        return lend; // 如果有一棵子树,左子树的结尾就是这棵子树的结尾
    } else {
        int rend = dfs(lend + 1); // 根据左子树的结尾递归右子树
        maxv[root][0] = max(maxv[root+1][1]+maxv[lend+1][2],maxv[root+1][2]+maxv[lend+1][1])+1;
        maxv[root][1] = max(maxv[root+1][0]+maxv[lend+1][2],maxv[root+1][2]+maxv[lend+1][0]);
        maxv[root][2] = max(maxv[root+1][0]+maxv[lend+1][1],maxv[root+1][1]+maxv[lend+1][0]);
        minv[root][0] = min(minv[root+1][1]+minv[lend+1][2],minv[root+1][2]+minv[lend+1][1])+1;
        minv[root][1] = min(minv[root+1][0]+minv[lend+1][2],minv[root+1][2]+minv[lend+1][0]);
        minv[root][2] = min(minv[root+1][0]+minv[lend+1][1],minv[root+1][1]+minv[lend+1][0]);
        return rend;  // 如果有两棵子树,右子树的结尾才是这棵子树的结尾
    }
}
int main() {
    cin >> s;
    dfs(0);
    // 三种情况选最大/最小
    cout<<max(maxv[0][0], max(maxv[0][1], maxv[0][2]))<<" "<<min(minv[0][0], min(minv[0][1], minv[0][2]))<<endl;
    return 0;
}

```

# P.S.

最近记忆力有点下降,这道题在两个网站上的数据范围不同,我照着第一个写,交到第二个上面,疯狂RE,死盯了半个小时也没找到原因...]]></description></item><item><title>BZOJ 4472 salesman 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/05/bzoj4472-salesman.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sun, 05 Apr 2020 04:36:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/05/bzoj4472-salesman.html</guid><description><![CDATA[# 题目

某售货员小T要到若干城镇去推销商品,由于该地区是交通不便的山区，任意两个城镇之间都只有唯一的可能经过其它城镇的路线。小T可以准确地估计出在每个城镇停留的净收益。这些净收益可能是负数，即推销商品的利润抵不上花费。由于交通不便，小T经过每个城镇都需要停留，在每个城镇的停留次数与在该地的净收益无关，因为很多费用不是计次收取的，而每个城镇对小T的商品需求也是相对固定的，停留一次后就饱和了。每个城镇为了强化治安，对外地人的最多停留次数有严格的规定。请你帮小T设计一个收益最大的巡回方案,即从家乡出发，在经过的每个城镇停留，最后回到家乡的旅行方案。你的程序只需输出最大收益，以及最优方案是否唯一。方案并不包括路线的细节，方案相同的标准是选择经过并停留的城镇是否相同。因为取消巡回也是一种方案，因此最大收益不会是负数。小T在家乡净收益是零，因为在家乡是本地人，家乡对小T当然没有停留次数的限制。

# 输入格式

输入的第一行是一个正整数$n(5<=n<=100000)$，表示城镇数目。城镇以$1$到$n$的数命名。小T的家乡命名为$1$。第二行和第三行都包含以空格隔开的$n-1$个整数，第二行的第$i$个数表示在城镇$i+1$停留的净收益。第三行的第$i$个数表示城镇$i+1$规定的最大停留次数。所有的最大停留次数都不小于$2$。接下来的$n-1$行每行两个１到$n$的正整数$x$，$y$，之间以一个空格隔开，表示$x$，$y$之间有一条不经过其它城镇的双向道路。输入数据保证所有城镇是连通的。 

# 输出格式

输出有两行，第一行包含一个自然数，表示巡回旅行的最大收益。如果该方案唯一，在第二行输出"solution is unique"，否则在第二行输出"solution is not unique"。

# 输入样例

```cpp
9
-3 -4 2 4 -2 3 4 6
4 4 2 2 2 2 2 2 
1 2
1 3
1 4
2 5
2 6
3 7
4 8 
4 9
```
# 输出样例

```
9
solution is unique
```
# 样例解释

最佳路线包括城镇 1，2， 4， 5， 9

# 题解

**任意两个城镇之间都只有唯一的可能经过其它城镇的路线**,说明这一定是一棵树

## 第一问

这道题明显是树形动规,但加了一个限制条件,就是最大停留次数,联想树形动规时的形式,这个最大停留次数其实和能访问的子树个数有关系.

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200405123516838-1433076673.png)



上图表示了一个DFS过程,其中2,3,4,5,6号都是子树,若将这些子树看成一个点,则DFS过程中经过的节点为

```
[1] 2 [1] 2 [1] 4 [1] 5 [1] 6 [1]
```

注意其中的根节点1,出现了6次,本题中就是停留了6次,而1号节点有5棵子树,可以发现,若i节点最大停留次数为$limit[x]$,则DFS中最多能访问$limit[x]-1$棵子树

这些子树中对根节点dp的贡献不同,我们当然要选择其中最大的,所以排一下序,选其中前$limit[x]-1$棵子树来更新根节点的dp值.

注意,$limit[x]-1$也存在大于子树个数的情况,所以实际操作的时候要取$limit[x]$和子树个数的最小值作为更新根节点的子树数量,由于净收益可能是负数,所以更新的时候发现是负数立刻停止即可.

所以遍历子树(已排序)时候,条件为

```
soni < min(limit[root] - 1, sontot) && dp[sonn[soni + 1]] >= 0
```

其中,`soni`为当前循环遍历的子树时的循环变量(注意不时子树根节点编号),`root`为根节点编号,`sontot`为子树的数量,`sonn`数组保存子树的根节点编号,`sonn[soni+1]`为这次循环的子树编号(因为soni在循环内自增1)

还有一个条件

>家乡对小T当然没有停留次数的限制

也就是整棵树的根节点无限制次数,那么只需要在DFS之前将根节点的`limit`值赋值为无限大即可

## 第二问

显然,根节点方案是否唯一首先要看其子树,如果有任意一棵更新了根节点dp值得子树的方案不唯一,根节点的方案显然也不唯一.

除此之外,还有存在子树方案唯一但根节点选取子树的方案不唯一的情况.

遍历子树的时候,将 子树方案是否唯一的值 和 根节点选取子树的方案是否唯一 的值进行或运算(只要有一个为真,结果就为真),得到的结果就是这棵树的方案是否唯一,最后输出即可.

那么怎么判断根节点选取子树的方案是否唯一呢,有两种情况:

1. 相同值引起的不唯一

假设排好序后的子树dp值为`10 9 8 7 6 6 5 4 3 2 1`,而你只能选5个(`limit`值为6),显然你选择的是`10 9 8 7 6`,但是仔细观察,你会发现还有一个相同的6,那么我能不能抛弃第一个6选择第二个6呢?当然可以,那么,这就有了两种选择办法(`[10] [9] [8] [7] [6] 6 5 4 3 2 1`和`[10] [9] [8] [7] 6 [6] 5 4 3 2 1`),这种情况不需要注意`limit`值的限制,因为没有多选择一个,是抛弃一个再选一个,用来更新的子树数量没有改变.

2. dp值为0引起的不唯一

假设排好序后的子树dp值为`10 9 8 7 6 0`,而你只能选5个(limit值为6),你可以选择`10 9 8 7 6`,也可以选择`10 9 8 7 6 0`,这两种方案更新的值都是一样的,这种情况需要注意`limit`值的限制,即使`limit`值为0,如果选择了,也会多一次停留<span class="heimu">,虽然数据有点水,亲测加不加limit值的限制都能A</span>.

出现这两种情况时,直接将这棵树方案是否唯一的赋值为真即可


# 代码

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 100000;
struct edge {
    int i, next;
} edges[2 * N + 5];
int head[N + 5], tot, n, w[N + 5], limit[N + 5], dp[N + 5], ansn[N + 5],sonn[N + 5];
void add(int u, int v) {
    edges[++tot].i = v;
    edges[tot].next = head[u];
    head[u] = tot;
}
bool cmp(int a, int b) { return dp[a] > dp[b]; }
void dfs(int root, int f) {
    dp[root] = w[root];
    int sontot = 0, soni = 0;
    for (int i = head[root]; i; i = edges[i].next)
        if (edges[i].i != f) dfs(edges[i].i, root);
    for (int i = head[root]; i; i = edges[i].next)
        if (edges[i].i != f) sonn[++sontot] = edges[i].i;
    sort(sonn + 1, sonn + 1 + sontot, cmp);
    while (soni < min(limit[root] - 1, sontot) && dp[sonn[soni + 1]] >= 0)
        dp[root] += dp[sonn[++soni]], ansn[root] |= ansn[sonn[soni]];//按位或
    if (soni < sontot && soni > 0 && dp[sonn[soni]] == dp[sonn[soni + 1]] || dp[sonn[soni]] == 0 && soni > 0 && soni <= limit[root] - 1)//两种情况,注意边界
        ansn[root] = 1;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) scanf("%d", &w[i + 1]);
    for (int i = 1; i < n; i++) scanf("%d", &limit[i + 1]);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v);
        add(v, u);
    }
    limit[1] = n + 1;//在家乡没有停留限制
    dfs(1, 0);
    printf("%d\n%s", dp[1], ansn[1] ? "solution is not unique" : "solution is unique");
    return 0;
}
```
]]></description></item><item><title>NEKO's Maze Game - Codeforces 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/04/04/neko-s-maze-game.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Sat, 04 Apr 2020 10:22:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/04/04/neko-s-maze-game.html</guid><description><![CDATA[# 题目

NEKO#ΦωΦ has just got a new maze game on her PC!

The game's main puzzle is a maze, in the forms of a $2×n$ rectangle grid. NEKO's task is to lead a Nekomimi girl from cell $(1,1)$ to the gate at $(2,n)$ and escape the maze. The girl can only move between cells sharing a common side.

However, at some moments during the game, some cells may change their state: either from normal ground to lava (which forbids movement into that cell), or vice versa (which makes that cell passable again). Initially all cells are of the ground type.

After hours of streaming, NEKO finally figured out there are only q such moments: the i-th moment toggles the state of cell $(ri,ci)$ (either from ground to lava or vice versa).

Knowing this, NEKO wonders, after each of the q moments, whether it is still possible to move from cell $(1,1)$ to cell $(2,n)$ andwithout going through any lava cells.

Although NEKO is a great streamer and gamer, she still can't get through quizzes and problems requiring large amount of Brain Power. Can you help her?

$2×n$的迷宫，从$(1,1)）$出发到$(2,n)$，初始时全部的都是地面，每次询问会把一个地面给变成熔浆，熔浆变成地面，熔浆不能通过，问是否可以走到。

# 输入格式

The first line contains integers$ n, q (2≤n≤105, 1≤q≤105)$.

The i-th of q following lines contains two integers $ri, ci (1≤ri≤2, 1≤ci≤n)$, denoting the coordinates of the cell to be flipped at the i-th moment.

It is guaranteed that cells $(1,1)$ and $(2,n)$ never appear in the query list.

第一行两个整数$n,q$.

接下来又q行,第$i$行包括两个整数,$ri, ci (1≤ri≤2, 1≤ci≤n)$,表示在第i个时刻要翻转的单元格的坐标.

确保单元格$(1,1)$和$(2,n)$永远不会出现在查询列表中。

# 输出格式

For each moment, if it is possible to travel from cell $(1,1)$ to cell $(2,n)$, print "Yes", otherwise print "No". There should be exactly q answers, one after every update.

对于每个时刻，如果可以从单元格$(1,1)$到单元格$(2,n)$，则打印"Yes"，否则打印"No",有q个答案，每行输入对应一行输出.

# 输入样例

```
5 5
2 3
1 4
2 4
2 3
1 4
```

# 输出样例

```
Yes
No
No
No
Yes
```

# 题解

这道题的大概思路还是挺好想的,大概就是每次输入的时候记录下挡路的"单元"

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200404182101617-467743414.png)


上图用圈出来的部分都是一个单元,可以阻挡玩家通过,如果整个地图只有一个熔浆单元格,显然是不足以构成一个单元,至少两个(上面三种情况)才可以构成.

那么思路就有了,如果在反转的时候对面三个格子已经有了熔浆单元,单元的数量加一.

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200404182116097-812467219.png)



在反转的时候,如果对面已经有了熔浆单元,说明这个格子在从地面到熔浆的过程中,单元的数量增加了,那么反转的时候自然要减回去.

还有一个小技巧,为了方便的表示"对面的x坐标",有三种方式:

1. 使用if语句,例如`#define o(x) ((x)==1?2:1)`,`o(x)`表示对面的横坐标

2. 因为$x$坐标有$1$和$2$两种情况,那么用3去减就可以了,同样可以推广,如果一个变量只有两个值的可能性$a$和$b$,使用同一种运算在a和b之间转化的方式就是$a+b-x$,例如当$x$为$a$,$a+b-a=b$;当$x$为$b$,$a+b-b=a$,在这道题中,$3-x$表示对面的横坐标.

3. 有没有感觉这种运算像取反操作?我们只要稍作修改,就可以使用取反来操作.在输入之后立刻`x--`,然后就可以用`!x`表示对面的横坐标,这种操作好在可以少开$10^5$大小的数组.

# 代码

```cpp
#include <cstdio>
int vis[2][100005];
int n, q, x, y, ans;
int main() {
    scanf("%d%d", &n, &q);
    while (q--) {
        scanf("%d%d", &x, &y);
        x--;
        if (vis[x][y]) {
            if (vis[!x][y]) ans--;
            if (vis[!x][y + 1] && y + 1 <= n) ans--;  //注意边界
            if (vis[!x][y - 1] && y - 1 >= 1) ans--;
        } else {
            if (vis[!x][y]) ans++;
            if (vis[!x][y + 1] && y + 1 <= n) ans++;
            if (vis[!x][y - 1] && y - 1 >= 1) ans++;
        }
        vis[x][y] = !vis[x][y];
        printf("%s\n", ans ? "No" : "Yes");
    }
}
```]]></description></item><item><title>离散化</title><link>http://www.cnblogs.com/youxam/archive/2020/03/26/discrete-fication.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Thu, 26 Mar 2020 02:00:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/03/26/discrete-fication.html</guid><description><![CDATA[# 前言
在做并查集的题目时,有的时候会遇到数据范围远大于数据个数的情况,这时候用普通的并查集就会导致MLE,例如下图:


![并查集的一种情况][1]

数据范围是1-7,但是只有5个节点,其中4,5节点并不在数据中,但是建立数组时,却也要建立大小等于数据范围大小(7)
的数组,当差距小时不明显,如果差距过大,就会导致严重的空间浪费,这时候,就要用离散化来解决.

# 基于map的离散化

题面:[洛谷P1955(NOI2015)程序自动分析](https://www.luogu.com.cn/problem/P1955)

这道题i,j的数据范围是[1,1e9],显然不能建这么大的并查集数组,该怎么离散化呢?

我觉得这道题用map离散化比较好.

## map介绍

先介绍一下map:

使用map时,首先包含头文件
```c++
#include<map>
```
定义时:
```c++
map<键数据类型,值数据类型> 名称;
```
例如
```c++
map<int,int> m;
```
表示定义一个`int-int`的`map`

使用时可以像数组一样使用下标赋值或获取值,当`map`中不存在此键时,会返回广义上的空,否则返回键所对应的值.

注意,即使`map`不存在键,返回空,但`map`中却会建立起一个键-空的关系,这个空值不会删除,所以必须处理好,否则会拖慢速度.

可以使用`map.find(key) == map.end()`来判断`map`中是否有`key`这个键,当表达式为真,不存在,当表达式为假,存在.

## 离散化

离散化的核心思想就是建立对应关系,对每一个值给一个编号,这个编号不像值可能是断断续续的,编号是连续的,

再看一下这个图:

![并查集的一种情况][1]

```
值 编号
1  1
2  2
3  3
6  4
7  5
```
然后对编号操作即可

代码:

```c++
#include <cstdio>
#include <iostream>
#include <map>
#include <vector>
using namespace std;
int t, n, x, y, e, fa[200005], flag, cnt, pcnt;
struct P{int a,b;}p[1000005];
map<int, int> m;
int find(int x) { return fa[x] == x ? x : (fa[x] = find(fa[x])); }
void join(int x, int y) { fa[find(x)] = find(y); }
bool in_one(int x, int y) { return find(x) == find(y); }
int main() {
    scanf("%d", &t);
    while (t--) {
        m.clear();
        flag = cnt = pcnt = 0;
        scanf("%d", &n);
        for (int i = 1; i <= 2 * n; ++i) fa[i] = i;
        for (int i = 1; i <= n; ++i) {
            scanf("%d%d%d", &x, &y, &e);
            if (m.find(x) != m.end()) // 当已经存在map中.说明已经分配了编号
                x = m[x]; //m[x]就是x的编号
            else {
                m[x] = ++cnt; //分配一个编号
                x = cnt; 
            }
            if (m.find(y) != m.end()) //对y进行相同操作
                y = m[y]; 
            else {
                m[y] = ++cnt;
                y = cnt;
            } 
            if (e) 
                join(x, y);
            else {
                p[pcnt].a=x;
                p[pcnt++].b=y;
            }
        }
        for (int i=0;i<pcnt;i++) {
            if (find(p[i].a) == find(p[i].b)) {
                printf("NO\n");
                goto end;
            }
        }
        printf("YES\n");
        end:1;
}
    return 0;
}
```

这道题只需要回答是否符合条件,光使用编号运算就够了,那么如果算完之后还需要输出原数据呢?

# 基于排序,去重和二分的离散化

(碎碎念:这篇文章本来是老姚让我分享给同学的,结果写到这里虎哥突然发了离散化的课件,就不用分享了...然后下面的内容差不多都是抄的虎哥的)

## unique函数

对某个区间（作为参数传入）的数据进行去重，返回去重的结果序列的最后一个元素的下一个指针

用下标解释:若去重后，不重复的元素有5个，假设最后一个元素的下标为5，则该函数返回6

例如有8个数：`2 1 2 4 1 4 3 5`

假设下标从1开始，即每个元素的地址分别为`&a[1]，&a[2] … &a[8]`

要对整个数列去重，可以调用函数`unique(a+1, a+1+8)`，去重后有效数据为`2 1 4 3 5`，分别存在`[1], a[2] … a[5]`里面，函数的返回值为指向`a[5]`的后面一个元素的指针，即`&a[6]`。因此我们要求不重复的元素的个数，需要：
`int size = unique(a+1, a+1+8) – (a+1)`

此时size存的值即为去重后不相同元素的个数。

## lower_bound函数

返回某个区间内第一个不小于查询的关键字key的元素的指针。

例如有5个数：`0 1 2 3 4`，如果在`a[1]`到`a[5]`这个区间查找数值3的lower_bound，则调用`lower_bound(a+1, a+1+5, 3)`，则返回值为`a[4]`的地址，即`&a[4]`，如果我们要得到它对应的下标，需要用返回值减去该数组的首地址，即：`int k = lower_bound(a+1, a+1+5, 3) – a;`

假设原数据存在a[i]数组里，b[i]为a[i]的一个副本（b与a相同）

```c++
std::sort(a + 1, a + 1 + n);
int size = std::unique(a + 1, a + 1 + n) – (a + 1);
int k;
for (int i = 1; i <= n; ++i){
    k = std::lower_bound(a + 1, a + 1 + size, b[i]) - a;
    printf("%d ", k);
    k = std::upper_bound(a + 1, a + 1 + size, b[i]) - a;
    printf("%d\n", k);
}
```


  [1]: https://img2020.cnblogs.com/blog/1975074/202003/1975074-20200326095900621-880716830.png]]></description></item><item><title>POJ2182 Lost Cows 题解</title><link>http://www.cnblogs.com/youxam/archive/2020/03/17/poj2182.html</link><dc:creator>YouXam</dc:creator><author>YouXam</author><pubDate>Tue, 17 Mar 2020 12:28:00 GMT</pubDate><guid>http://www.cnblogs.com/youxam/archive/2020/03/17/poj2182.html</guid><description><![CDATA[# POJ2182 Lost Cows 题解

## 题目

有$N$($2 <= N <= 8,000$)头母牛,每头母牛有自己的独一无二编号($1..N$).

现在$N$头母牛站成一列,已知每头母牛前面编号比它小的母牛数量,求每头母牛的编号.

## 输入格式

第1行 : 一个整数 $N$

第2..N行 : 从 第2头母牛到第N头母牛 的 前面编号比它小的母牛数量

## 输入样例
```c++
5
1
2
1
0
```
## 输出样例
```c++
2
4
5
3
1
```

## 题解

先手造一组数据
```c++
2 1 5 4 3  // 编号序列
```
设比第$i$头牛前面比它编号小的牛的数量为$A_i$,编号为$B_i$

可以发现,最后一头牛编号为3,前面有2头编号比它小的牛.因为所有编号比它小的点都在前面,所以,$B_N=A_N+1$

同理,对于倒数第二头牛
1. 若$A_{N-1}<A_N$,则$B_{N-1}=A_{N-1}+1$,唯一在它后面的第$N$头牛编号比它大,所以所有编号比它小的点都在前面,例如 :
```c++
3 4 2 1 5 // 编号序列
```
因为$0=A_4<A_5=4$,则$B_4=A_4+1=0+1=1$

2. 若$A_{N-1}>A_N$,则$B_{N-1}=A_{N-1}+2$,相比第一条,最后一头牛编号也比它小,额外加上1,例如 :
```c++
3 4 2 5 1  // 编号序列
```
因为$3=A_4>A_5=0$,则$B_4=A_4+2=3+2=5$

因为第i头牛前面有$A_i$头牛编号比它小,所以$B_i$至少是$A_i+1$(也就是从第$1$到第$i-1$头牛都在这头牛的前面的情况),如果后面的牛还有比它小的,那么这头牛的编号又要增加,所以$B_i$为$1..N$中去掉$B_{i+1}$..$B_N$中的数 后 从前往后的第$A_i+1$个数

建立一个长度为$N$的数组c,初始化为$1$

因为要去掉后面的数,所以从后往前扫描$A_i$,对于每个$A_i$,查询该数组中第$A_i+1$个"1"的位置,此位置的下标就是$B_i$,然后$c[B_i]=0$,这是在去掉$B_{i+1}$..$B_N$中的数

使用样例数据模拟一遍

```c++
 0 1 2 1 0  // A序列(省略A[0])
```

开始扫描

```c++
 1 1 1 1 1  // c数组(省略c[0])
```
第一次 : $A_5=0$,第$0+1$个"1"的下标为$1$,则$B_5=1$

```c++
[0]1 1 1 1  // c数组(省略c[0])
```
第二次 : $A_4=1$,第$1+1$个"1"的下标为$3$,则$B_4=3$

```c++
 0 1[0]1 1  // c数组(省略c[0])
```
第三次 : $A_3=2$,第$2+1$个"1"的下标为$5$,则$B_3=5$

```c++
 0 1 0 1[0] // c数组(省略c[0])
```
第四次 : $A_2=3$,第$3+1$个"1"的下标为$4$,则$B_2=4$

```c++
 0 1 0[0]0  // c数组(省略c[0])
```
第五次 : $A_1=0$,第$0+1$个"1"的下标为$2$,则$B_1=2$

将B数组顺序输出出来即可

至于怎么求第$A_i+1$个"1",就需要使用树状数组维护c数组的前缀和,每次查询时使用二分

## 代码

```c++
// Memory       :704 KB
// Time         :94 MS
// Code Length  :965 B
#include <cstdio>
#include <iostream>
#define lowbit(x) ((x)&(-x))
using namespace std;
const int N = 8005;
int n, a[N], c[N], h[N];

void add(int x) {
    while (x <= n) {
        c[x]--;
        x += lowbit(x);
    }
}

int ask(int x) {
    int ans = 0;
    while (x) {
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}

int main() {
    scanf("%d",&n);
    for (int i = 1; i <= n; i++) {
        // 初始化树状数组
        c[i]++;
        if (i + lowbit(i) <= n) c[i + lowbit(i)] += c[i];
    }
    a[1] = 1;  // 本来为0,提前加1
    for (int i = 2; i <= n; i++) {
        scanf("%d", &a[i]); 
        a[i]++; //提前加1
    }
    for (int i = n; i; i--) {
        // 二分
        int l = 1, r = n;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (ask(mid) < a[i]) l = mid + 1;
            else r = mid;
        }
        // 记录答案,并更新树状数组
        add(h[i] = l);
    }
    for (int i = 1; i <= n; i++) printf("%d\n", h[i]);
    return 0;
}
```
]]></description></item></channel></rss>