# 题目

米特是D星球上一种非常神秘的物质，蕴含着巨大的能量。在以米特为主要能源的D星上，这种米特能源的运输和储存一直是一个大问题。D星上有N个城市，我们将其顺序编号为1到N，1号城市为首都。这N个城市由N-1条单向高速通道连接起来，构成一棵以1号城市（首部）为根的树，高速通道的方向由树中的儿子指向父亲。树按深度分层：根结点深度为0，属于第1层；根结点的子节点深度为1，属于第2层；依此类推，深度为i的结点属于第i+l层。建好高速通道之后，D星人开始考虑如何具体地储存和传输米特资源。由于发展程度不同，每个城市储存米特的能力不尽相同，其中第i个城市建有一个容量为A[i]的米特储存器。这个米特储存器除了具有储存的功能，还具有自动收集米特的能力。如果到了晚上六点，有某个储存器处于未满的状态，它就会自动收集大气中蕴含的米特能源，在早上六点之前就能收集满；但是，只有在储存器完全空的状态下启动自动收集程序才是安全的，未满而又非空时启动可能有安全隐患。早上六点到七点间，根节点城市（1号城市）会将其储存器里的米特消耗殆尽。根节点不会自动搜集米特，它只接受子节点传输来的米特。早上七点，城市之间启动米特传输过程，传输过程逐层递进：先是第2层节点城市向第1层（根节点城市，即1号城市）传输，直到第1层的储存器满或第2层的储存器全为空；然后是第3层向第2层传输，直到对于第2层的每个节点，其储存器满或其予节点（位于第3层）的储存器全为空；依此类推，直到最后一层传输完成。传输过程一定会在晚上六点前完成。

由于技术原因，运输方案需要满足以下条件：

1. 不能让某个储存器到了晚上六点传输结束时还处于非空但又未满的状态，这个时候储存器仍然会启动自动收集
米特的程序，而给已经储存有米特的储存器启动收集程序可能导致危险，也就是说要让储存器到了晚上六点时要么
空要么满；

2. 关于首都——即1号城市的特殊情况，  每天早上六点到七点间1号城市中的米特储存器里的米特会自动被消耗
殆尽，即运输方案不需要考虑首都的米特怎么运走；

3. 除了1号城市，每个节点必须在其子节点城市向它运输米特之前将这座城市的米特储存器中原本存有的米特全部
运出去给父节点，不允许储存器中残存的米特与外来的米特发生混合；

4. 运向某一个城市的若干个来源的米特数量必须完全相同，不然，这些来源不同的米特按不同比例混合之后可能
发生危险。

现在D星人已经建立好高速通道，每个城市也有了一定储存容量的米特储存器。为了满足上面的限制条件，可能需要重建一些城市中的米特储存器。你可以，也只能，将某一座城市（包括首都）中原来存在的米特储存器摧毁，再新建一座任意容量的新的米特储存器，其容量可以是小数（在输入数据中，储存器原始容量是正整数，但重建后可以是小数），不能是负数或零，使得需要被重建的米特储存器的数目尽量少。

# 输入格式

第一行是一个正整数$N$，表示城市的数目。接下来$N$行，每行一个正整数，其中的第$i$行表示第$i$个城市原来存在的米特储存器的容量。再接下来是$N-i$行，每行两个正整数a，b表示城市b到城市a有一条高速通道$(a \ne b)$。$N<500000，A[j]<10^8$

# 输出格式

输出文件仅包含一行，一个整数，表示最少的被重建（即修改储存器容量）的米特储存器的数目。

# 输入样例

```
5
5
4
3
2
1
1 2
1 3
2 4
2 5
```

# 输出样例

```
3
```

# 样例解释

一个最优解是将$A[1]$改成8，$A[3]$改成4，$A[5]$改成2。
这样，2和3运给1的量相等，4和5运给2的量相等，且每天晚上六点的时候，1，2满，3，4，5空，满足所有限制条件。

# 题解

看题快把我累死了。。。

一句话题意：**用最少次数改变权值，使每个节点的的子节点权值相同，且权值为除叶节点以外的子节点权值和，权值可以为小数但大于0**。

只要一个点的权值确定，所有点的权值就确定：

假设某节点的权值确定，则其兄弟节点的权值必定与其相同；其父节点权值必定等于该节点和其兄弟节点权值之和；其子节点权值必定等于该节点权值除以子节点数量。

dfs求保持某个节点不变的情况下根节点的权值，此时只保证一个点不变。

假设$A$不变，根节点权值为$W_A$，$B$不变，根节点权值为$W_B$

如果存在$A,B$，使$W_A=W_B$，那么可以同时让$A$,$B$保持不变，此时保证两个点不变，需要改变权值的数量减少一次。

那么对根节点权值的可能性计数，出现最多的情况权值就是最优情况下的权值。

注意，通过取对数，可以使乘法运算变成加法运算。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 5;
double w[maxn];
int a[maxn], in[maxn], value[maxn], vis[maxn << 1], next[maxn << 1], head[maxn << 1], tot = 0,ans = 0, t = 1;
inline void add(int x, int y) { vis[++tot] = y, next[tot] = head[x], head[x] = tot; }
void dfs(int v) {
    value[v] = 1;
    for (int i = head[v]; i; i = next[i])
        if (!value[vis[i]]) w[vis[i]] = w[v] + log(in[v]), dfs(vis[i]);
}
inline int input() { int t; scanf("%d", &t); return t; }
int main() {
    int n = input();
    for (int i = 1; i <= n; i++) a[i] = input();
    for (int i = 2; i <= n; i++) {
        int x = input(), y = input();
        add(x, y), add(y, x);
        in[x]++, in[y]++, in[i]--;
    }
    w[1] = log(1), dfs(1);
    for (int i = 1; i <= n; i++) w[i] += log(a[i]);
    sort(w + 1, w + n + 1);
    for (int i = 2; i <= n; i++)
        if (w[i] - w[i - 1] < 1e-7)t++;
        else ans = max(ans, t), t = 1;
    printf("%d",n - max(ans, t));
    return 0;
}
```
